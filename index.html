<!DOCTYPE html><html lang="zh-CN"><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><meta name="author" content="WHD"><title>藤原拓海</title><meta name="description" content="等到放晴的那天也许我会比较好一点"><meta name="keywords" content="Blog,博客,Hexo"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="renderer" content="webkit"><link rel="shortcut icon" type="image/x-icon" href="/images/favicon.webp"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/blog_basic.css"><link rel="stylesheet" href="/css/font-awesome.min.css"><link rel="stylesheet" href="/css/insight.css"><link rel="stylesheet" href="/css/search.css"><link rel="alternate" type="application/atom+xml" title="ATOM 1.0" href="/atom.xml"><script src="/js/jquery.js"></script><meta name="generator" content="Hexo 6.3.0"></head><body><div class="page-top animated fadeInDown"><div class="nav"><li> <a class="current" href="/">Home</a></li><li> <a href="/archives">Archives</a></li><li> <a href="/tags">Tags</a></li><li> <a href="/about">About</a></li><li> <a href="/links">Links</a></li></div><div class="information"><div class="nav_right_btn"><li><a class="fa fa-chevron-left" onclick="window.history.go(-1)" style="display:none;"> </a></li><li><a class="fa fa-search" onclick="openWindow();"></a></li></div><div class="avatar"><img src="/images/logo.webp"></div></div></div><div class="sidebar animated fadeInDown"><div class="sidebar-top"><div class="logo-title"><div class="title"><img src="/images/logo@2x.webp" style="width:220px;" alt="favicon"><h3 title=""><a href="/">藤原拓海</a></h3><div class="description"><p>等到放晴的那天也许我会比较好一点</p></div></div><ul class="social-links"><li><a target="_blank" rel="noopener" href="https://github.com/Lhcfl"><i class="fa fa-github"></i></a></li><li><a href="mailto:yourname@example.com"><i class="fa fa-envelope"></i></a></li><li><a target="_blank" rel="noopener" href="https://zhihu.com/people/jin-xin-4-68"><i class="fa fa-mortar-board"></i></a></li></ul></div></div><div class="footer"><div class="p"> <span> 但故事最后你好像还是说了 拜 </span><i class="fa fa-star"></i><span> WHD</span></div><div class="by_farbox"><span>Powered by </span><a href="https://hexo.io/zh-cn/" target="_blank">Hexo </a><span> & </span><span>Anatolo </span></div><div class="beian"></div></div></div><div class="main"><div class="autopagerize_page_element"><div class="content"><div class="post animated fadeInDown"><div class="post-title"><h3><a href="/2023/02/21/JavaScript%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/">JavaScript基础知识</a></h3></div><div class="post-content"><div class="card"><p><h3 id="事件循环"><a href="#事件循环" class="headerlink" title="事件循环"></a>事件循环</h3><h4 id="异步执行原理"><a href="#异步执行原理" class="headerlink" title="异步执行原理"></a>异步执行原理</h4><p>1）单线程的JavaScript</p>
<p>​	JS是单线程语言，有同步和异步的概念</p>
<p>2）多线程的浏览器</p>
<p>​	浏览器是多线程的，当js需要执行异步任务的时候，浏览器会另外启动一个线程执行。</p>
<h4 id="浏览器的事件循环"><a href="#浏览器的事件循环" class="headerlink" title="浏览器的事件循环"></a>浏览器的事件循环</h4><p>​	由于JS是单线程，为了防止一个函数执行事件过长阻塞后面的代码，所以会先将同步代码放入执行栈中先执行，异步代码放入任务队列中等待，任务队列又分为宏任务队列（<strong>setImmediate</strong>  <strong>setTimeout</strong>  <strong>setInterval</strong>），微任务队列（promise.then）,先执行微任务队列中的任务，等清空之后，弹出一个宏任务执行，然后检查微任务是否清空，反复上述操作，直至所有任务结束</p>
<h4 id="Node环境中的事件循环"><a href="#Node环境中的事件循环" class="headerlink" title="Node环境中的事件循环"></a>Node环境中的事件循环</h4><p>​	<img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e362c1770f62428fbf3faabd99d2a64c~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp" alt="2020120317343116.png"></p>
<p>执行顺序</p>
<p><code>timers</code>: 计时器，执行setTimeout和setInterval的回调</p>
<p><code>pending callbacks</code>: 执行延迟到下一个循环迭代的 I&#x2F;O 回调</p>
<p><code>idle, prepare</code>: 队列的移动，仅系统内部使用</p>
<p><code>poll轮询</code>: 检索新的 I&#x2F;O 事件;执行与 I&#x2F;O 相关的回调。事实上除了其他几个阶段处理的事情，其他几乎所有的异步都在这个阶段处理。</p>
<p><code>check</code>: 执行<code>setImmediate</code>回调，setImmediate在这里执行</p>
<p><code>close callbacks</code>: 执行<code>close</code>事件的<code>callback</code>，一些关闭的回调函数，如：socket.on(‘close’, …)</p>
<h3 id="数据去重的方法"><a href="#数据去重的方法" class="headerlink" title="数据去重的方法"></a>数据去重的方法</h3><ul>
<li>使用SET</li>
<li>遍历 使用splice删除</li>
<li>indexof</li>
</ul>
<h3 id="JS中八种数据类型以及区别"><a href="#JS中八种数据类型以及区别" class="headerlink" title="JS中八种数据类型以及区别"></a>JS中八种数据类型以及区别</h3><ul>
<li>基本类型（占固定大小，保存在栈内存中）<ul>
<li>Number、String、Boolean、null、undefined、<strong>Symbol（符号）</strong></li>
</ul>
</li>
<li>引用类型（地址保存在栈内存，值保存在堆内存中）<ul>
<li>Object、Function</li>
</ul>
</li>
</ul>
<h3 id="JS中的数据类型检测的方法"><a href="#JS中的数据类型检测的方法" class="headerlink" title="JS中的数据类型检测的方法"></a>JS中的数据类型检测的方法</h3><ul>
<li><code>typeof</code>: <ul>
<li>用法 ： <code>typeof null</code>   return object</li>
<li>优点：可以快速区分基本数据类型</li>
<li>缺点：<strong>不能将Object、Array和Null区分</strong>，都返回object</li>
</ul>
</li>
<li><code>instanceof</code><ul>
<li>用法： <code>1 instanceof Number</code>  return false</li>
<li>优点：可以区分Object、Array和Function，适合用于判断自定义的类实例对象</li>
<li>缺点：Number、Boolean、String 不能判断</li>
</ul>
</li>
<li><code>Object.prototype.toString.call()</code><ul>
<li>万能</li>
</ul>
</li>
</ul>
<h3 id="var、-let、-const"><a href="#var、-let、-const" class="headerlink" title="var、 let、 const"></a>var、 let、 const</h3><ul>
<li>三者区别<ul>
<li>var可以<strong>先使用，再声明</strong>（变量提升），let 和 const 不行</li>
<li>var 可以<strong>跨块使用</strong>（注意不是函数），let 和 const 不行，且const常用来声明常量，不可以更改</li>
<li>var 可以重复声明同一个变量 例如 <code>var a = 1 ; var a = 2</code>,let 和const 不行</li>
<li>var 声明的全局变量 会映射（挂载）再全局对象上，通过<code>window.变量名</code>可以访问到，而用 let 和 const 声明的全局变量并没有在全局对象中，只是一个块级作用域（Script）中</li>
<li>在使用let声明变量之前使用该变量，会产生<strong>暂时性死区</strong></li>
<li>let &#x2F;const&#x2F;function会把当前所在的大括号(除函数之外)作为一个全新的块级上下文</li>
</ul>
</li>
</ul>
<h3 id="匿名函数和普通函数的区别"><a href="#匿名函数和普通函数的区别" class="headerlink" title="匿名函数和普通函数的区别"></a>匿名函数和普通函数的区别</h3><ul>
<li>普通函数在定义时，就已经创建了 函数对象 和 作用域链对象，所以即使没有调用，也占用内存空间</li>
<li><strong>匿名函数只在调用时才创建，调用完立即释放</strong>，所以比普通函数更节省内存空间<ul>
<li>多用于 回调函数</li>
</ul>
</li>
</ul>
<h3 id="JS垃圾回收机制"><a href="#JS垃圾回收机制" class="headerlink" title="JS垃圾回收机制"></a>JS垃圾回收机制</h3><ul>
<li><p>为什么要有垃圾回收机制</p>
<ul>
<li>在一个项目中，如果有大量不被释放的内存，页面性能就会变得很慢。同时，当某些代码操作不能被合理释放，就会造成内存泄漏。所以垃圾回收机制也称为内存回收机制</li>
</ul>
</li>
<li><p>浏览器垃圾回收机制（GC）</p>
<ul>
<li>浏览器的JS具有自动垃圾回收机制，它会周期性检查那些不在继续使用的变量并释放</li>
<li>具体方法<ul>
<li><strong>标记清除：</strong>当变量进入环境，被标记为“进入环境”，离开时，被标记为“离开环境”，垃圾回收器会释放带有标记的变量空间</li>
<li><strong>谷歌浏览器：****查找引用</strong>，不定时的检查当前内存的引用，如果其没被占用，则回收</li>
<li><strong>IE浏览器：****引用计数法</strong>，当前内存被占用时计数加一，释放计数减一，到0时，回收</li>
</ul>
</li>
</ul>
</li>
<li><p>优化手段：内存优化 ; 手动释放：取消内存的占用即可。</p>
<p>（1）堆内存：fn &#x3D; null 【null：空指针对象】</p>
<p>（2）栈内存：把上下文中，被外部占用的堆的占用取消即可。</p>
</li>
<li><p>内存泄漏</p>
</li>
</ul>
<h3 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h3><ul>
<li><p>什么是闭包</p>
<p>有权访问另一个函数作用域中的变量的函数，一般实现是在一个函数中包含另一个函数。拥有保存和保护的作用</p>
</li>
<li><p>保存：如果外界将闭包的返回接收，则闭包内的数据不会被回收，会一直被保存在内存中，直到手动释放。如果被接收，则使用完毕会自动释放。（可能引起<strong>内存泄漏</strong>）</p>
</li>
<li><p>保护：体现在函数外部的操作无法影响到内部的数据，可以设置私有的方法和变量，避免全局变量的污染。</p>
</li>
<li><p>应用场景：事件绑定的回调方法；setTinmeout延时回调</p>
</li>
</ul>
<h3 id="访问对象的属性"><a href="#访问对象的属性" class="headerlink" title="访问对象的属性"></a>访问对象的属性</h3><p>两种方式：“.”  和 “[]”</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> object = &#123;<span class="attr">name</span>:<span class="string">&#x27;xiaoming&#x27;</span>,<span class="attr">age</span>:<span class="number">29</span>&#125;;</span><br><span class="line"><span class="keyword">var</span> name1 = object.<span class="property">name</span>;</span><br><span class="line"><span class="keyword">var</span> name2 = object[<span class="string">&#x27;name&#x27;</span>];</span><br></pre></td></tr></table></figure>

<h3 id="JS循环遍历数组（对象）的方法"><a href="#JS循环遍历数组（对象）的方法" class="headerlink" title="JS循环遍历数组（对象）的方法"></a>JS循环遍历数组（对象）的方法</h3><ul>
<li><p><code>for(let index in ...) </code></p>
<ul>
<li>不推荐迭代数组<ul>
<li><strong>遍历的属性值是字符串</strong></li>
<li><strong>遍历顺序是对象属性的枚举顺序，并不一定按数组的下标顺序遍历</strong></li>
</ul>
</li>
<li>多用于检查对象属性<ul>
<li><strong>遍历的对象的话，会将对象所有自身属性以及原型链上的属性都遍历出来</strong></li>
</ul>
</li>
<li></li>
</ul>
</li>
<li><h2 id="for-const-item-of"><a href="#for-const-item-of" class="headerlink" title="for(const item of ...)"></a><code>for(const item of ...)</code></h2></li>
<li><p><code>arr.forEach((value, index, arr2) =&gt; &#123;&#125;)</code></p>
<ul>
<li>不能使用continue，break</li>
<li>其中，arr和arr2 指向同一块地址</li>
<li>value 只是值引用</li>
</ul>
</li>
<li><p><code>for循环</code></p>
</li>
<li><p><code>arr.every((value, index, arr2) =&gt; &#123;&#125;)</code></p>
<ul>
<li>该方法测试一个数组内的所有元素是否都能通过某个指定函数的测试。</li>
<li>返回值为boolean，默认是false</li>
</ul>
</li>
<li><p><code>arr.some(callback(element[, index[, array]])[, thisArg])</code></p>
<ul>
<li>只要数组中存在某一个符合条件的就返回<code>true</code></li>
</ul>
</li>
<li><p>filter()方法</p>
</li>
<li><p><code>arr.map((value) =&gt; &#123;&#125;)</code></p>
<ul>
<li>对每一个数组元素应用函数，并返回一个新的数组</li>
</ul>
</li>
<li><p>reduce()</p>
</li>
</ul>
<h3 id="this的五种情况"><a href="#this的五种情况" class="headerlink" title="this的五种情况"></a>this的五种情况</h3><ul>
<li>普通函数的this</li>
<li>对象方法的this</li>
<li>构造器调用</li>
</ul>
<h3 id="JS中的call、apply、bind"><a href="#JS中的call、apply、bind" class="headerlink" title="JS中的call、apply、bind"></a>JS中的call、apply、bind</h3><ul>
<li>bind是<strong>返回一个新函数</strong>，便于稍后回调；apply和call是<strong>立即调用</strong></li>
<li>apply接收<strong>数组</strong>作为参数，call 一个一个接收</li>
<li>bind<ul>
<li><code>bind()</code>最简单的用法是创建一个函数，使这个函数不论怎么调用都有同样的this值。</li>
</ul>
</li>
</ul>
<h3 id="函数提升-和-变量提升的优先级"><a href="#函数提升-和-变量提升的优先级" class="headerlink" title="函数提升 和 变量提升的优先级"></a>函数提升 和 变量提升的优先级</h3><ul>
<li><strong>函数提升</strong> 在 <strong>变量提升</strong>之前</li>
<li><strong>函数被提升的时候，声明和赋值都被提升</strong>，变量只提升声明步骤</li>
</ul>
<h3 id="Promise"><a href="#Promise" class="headerlink" title="Promise"></a>Promise</h3><h4 id="A-规范"><a href="#A-规范" class="headerlink" title="A+规范"></a>A+规范</h4><ul>
<li><code>new Promise(executor)</code> 其中executor是执行器，new完一个promise对象对立即执行</li>
<li>executor 接收两个参数 <code>executor(resolve, reject)</code><ul>
<li>resolve – 将promise实例的状态从pending – &gt;  fulfilled</li>
<li>reject – 将promise 实例的状态 从pending –&gt; rejected</li>
<li>状态只能改变一次</li>
<li>改变状态的同时可以修改 value 和 reason</li>
</ul>
</li>
<li>每个promise实例中都要有一个then函数，<code>then(onFulfilled, onRejected)</code><ul>
<li>接受两个参数（可选）</li>
<li><code>onFulfilled</code>– 状态为fufilled时的回调函数</li>
<li><code>onRejected</code>–状态为rejected的回调函数</li>
</ul>
</li>
<li>可以使用订阅者-发布者模式处理异步executor</li>
</ul>
<h3 id="AJax-中-post-和-get的区别"><a href="#AJax-中-post-和-get的区别" class="headerlink" title="AJax 中 post 和 get的区别"></a>AJax 中 post 和 get的区别</h3><p>1、使用GET请求时，参数会在URL显示，Post不会</p>
<p>2、使用GET请求<strong>发送数据量小</strong>，Post请求<strong>发送数据量大</strong></p>
<p>3、get请求需要注意<strong>缓存问题</strong>（会被客户端的浏览器缓存起来）</p>
<h3 id="JS继承的理解"><a href="#JS继承的理解" class="headerlink" title="JS继承的理解"></a>JS继承的理解</h3><p>​	继承的意思是当一个子类继承一个父类时，该子类将拥有父类的属性和方法，同时子类可以改写父类方法或属性，添加新的属性和方法，实现代码复用。</p>
<h4 id="实现继承的方法"><a href="#实现继承的方法" class="headerlink" title="实现继承的方法"></a>实现继承的方法</h4><ul>
<li>原型链继承</li>
<li>构造函数继承</li>
<li>组合继承</li>
<li>原型式继承</li>
</ul>
<h3 id="原型-和-原型链"><a href="#原型-和-原型链" class="headerlink" title="原型 和 原型链"></a>原型 和 原型链</h3><ul>
<li><p>原型</p>
<ul>
<li>原型分类两种，一种式隐式原型，一种是显式原型<ul>
<li>隐式原型（<code>__proto__</code>）：对象自有属性，指向显示原型对象</li>
<li>显示原型（prototype）：指向该对象的构造函数的原型对象</li>
</ul>
</li>
</ul>
</li>
<li><p>原型链</p>
<p>个人理解就是由于隐式原型指向显示原型，所以对象可以通过这样一个关系向上一层一层查找属性和方法，从而使用到不属于自己的属性和方法。最上层的原型是Objet.prototype,指向null。</p>
<ul>
<li>判断是否是自身属性 — <code>hasOwnPropery</code></li>
</ul>
</li>
<li><p>原型链继承方法</p>
<ul>
<li>先调用父类的构造方法 –call</li>
<li>定义一个空函数，空函数的prototype指向父类的prototype</li>
<li>子类的prototype指向该空函数的对象</li>
<li>修改子类的构造方法</li>
</ul>
</li>
</ul>
</p></div></div><div class="post-footer"><div class="meta"><div class="info"><i class="fa fa-sun-o"></i><span class="date">2023-02-21</span><span class="leancloud_visitors"></span><span>About 2457 words, 8 min 11 sec  read</span></div></div></div></div><div class="post animated fadeInDown"><div class="post-title"><h3><a href="/2022/11/17/%E8%A7%A3%E6%9E%84%E8%B5%8B%E5%80%BC/">解构赋值</a></h3></div><div class="post-content"><div class="card"><p><blockquote>
<p>解构赋值是一种特殊语法，可以使数组或对象拆包至一系列变量</p>
</blockquote>
<h2 id="数组解构"><a href="#数组解构" class="headerlink" title="数组解构"></a>数组解构</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 解构赋值</span></span><br><span class="line"><span class="comment">// 设置 firstName = arr[0]</span></span><br><span class="line"><span class="comment">// 以及 surname = arr[1]</span></span><br><span class="line"><span class="keyword">let</span> [firstName, surname] = arr;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>注意点</strong><ul>
<li>解构操作不影响原数组或对象</li>
<li>可以使用逗号忽略原数组或对象中不想要的元素</li>
<li>被结构对象可以是任何可迭代的对象</li>
<li>被赋值的元素类型不限</li>
<li>可以配合 <code>Object.entries(obj)</code> 方法一同使用</li>
</ul>
</li>
</ul>
<h3 id="页面生命周期：DOMContentLoaded，load，beforeunload，unload"><a href="#页面生命周期：DOMContentLoaded，load，beforeunload，unload" class="headerlink" title="页面生命周期：DOMContentLoaded，load，beforeunload，unload"></a>页面生命周期：DOMContentLoaded，load，beforeunload，unload</h3><p><strong>HTML 页面的生命周期包含三个重要事件</strong>：</p>
<ul>
<li><code>DOMContentLoaded</code> —— 浏览器已完全加载 HTML，并构建了 DOM 树，但像 <code>&lt;img&gt;</code> 和样式表之类的<strong>外部资源</strong>可能尚未加载完成。</li>
<li><code>load</code> —— 浏览器不仅加载完成了 HTML，还加载完成了所有外部资源：图片，样式等。</li>
<li><code>beforeunload/unload</code> —— 当用户正在离开页面时。</li>
</ul>
<p><strong>每个事件都是有用的</strong>：</p>
<ul>
<li><code>DOMContentLoaded</code> 事件 —— DOM 已经就绪，因此处理程序可以查找 DOM 节点，并初始化接口。</li>
<li><code>load</code> 事件 —— 外部资源已加载完成，样式已被应用，图片大小也已知了。</li>
<li><code>beforeunload</code> 事件 —— 用户正在离开：我们可以检查用户是否保存了更改，并询问他是否真的要离开。</li>
<li><code>unload</code> 事件 —— 用户几乎已经离开了，但是我们仍然可以启动一些操作，例如发送统计数据。</li>
</ul>
<p><strong>页面生命周期事件：</strong></p>
<ul>
<li><p>当 DOM 准备就绪时，<code>document</code>上的<code>DOMContentLoaded</code>事件就会被触发。在这个阶段，我们可以将 JavaScript 应用于元素。</p>
<ul>
<li>诸如 <code>&lt;script&gt;...&lt;/script&gt;</code> 或 <code>&lt;script src=&quot;...&quot;&gt;&lt;/script&gt;</code> 之类的脚本会阻塞 <code>DOMContentLoaded</code>，浏览器将等待它们执行结束。</li>
<li>图片和其他资源仍然可以继续被加载。</li>
</ul>
</li>
<li><p>当页面和所有资源都加载完成时，<code>window</code> 上的 <code>load</code> 事件就会被触发。我们很少使用它，因为通常无需等待那么长时间。</p>
</li>
<li><p>当用户想要离开页面时，<code>window</code> 上的 <code>beforeunload</code> 事件就会被触发。如果我们取消这个事件，浏览器就会询问我们是否真的要离开（例如，我们有未保存的更改）。</p>
</li>
<li><p>当用户最终离开时，<code>window</code> 上的 <code>unload</code> 事件就会被触发。在处理程序中，我们只能执行不涉及延迟或询问用户的简单操作。正是由于这个限制，它很少被使用。我们可以使用 <code>navigator.sendBeacon</code> 来发送网络请求。</p>
<p><code>document.readyState</code>是文档的当前状态，可以在<code>readystatechange</code>事件中跟踪状态更改：</p>
<ul>
<li><code>loading</code> —— 文档正在被加载。</li>
<li><code>interactive</code> —— 文档已被解析完成，与 <code>DOMContentLoaded</code> 几乎同时发生，但是在 <code>DOMContentLoaded</code> 之前发生。</li>
<li><code>complete</code> —— 文档和资源均已加载完成，与 <code>window.onload</code> 几乎同时发生，但是在 <code>window.onload</code> 之前发生。</li>
</ul>
</li>
</ul>
</p></div></div><div class="post-footer"><div class="meta"><div class="info"><i class="fa fa-sun-o"></i><span class="date">2022-11-17</span><i class="fa fa-tag"></i><a class="tag" href="/tags/计算机知识杂烩/" title="计算机知识杂烩">计算机知识杂烩 </a><span class="leancloud_visitors"></span><span>About 803 words, 2 min 40 sec  read</span></div></div></div></div><div class="post animated fadeInDown"><div class="post-title"><h3><a href="/2022/11/17/Vue-%E4%BE%A6%E5%90%AC%E5%99%A8%E5%92%8C%E8%AE%A1%E7%AE%97%E5%B1%9E%E6%80%A7/">Vue-侦听器和计算属性</a></h3></div><div class="post-content"><div class="card"><p><h2 id="侦听器-监听器-watch"><a href="#侦听器-监听器-watch" class="headerlink" title="侦听器(监听器 watch)"></a>侦听器(监听器 watch)</h2><blockquote>
<p>watch 侦听器允许开发者监视数据的变化，从而针对数据的变化做特定的操作</p>
</blockquote>
<ul>
<li><p><strong>应用场景</strong></p>
<ul>
<li>判断用户名是否被占用</li>
</ul>
</li>
<li><p><strong>方法格式的侦听器</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">watch</span>:&#123;</span><br><span class="line"><span class="comment">// 函数类型的侦听器</span></span><br><span class="line">	<span class="title function_">username</span>(<span class="params">newUsername, username</span>)&#123;</span><br><span class="line">	$.<span class="title function_">get</span>(<span class="string">&#x27;https://www.escook.cn/api/finduser/&#x27;</span> + newUsername, <span class="keyword">function</span>(<span class="params">res</span>) &#123;</span><br><span class="line">		<span class="variable language_">console</span>.<span class="title function_">log</span>(res);</span><br><span class="line">	&#125;)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>缺点</strong>：</p>
<ol>
<li><p>无法立即触发（可以使用对象类型的 <code>immediate属性</code> 侦听器解决）</p>
</li>
<li><p>如果侦听的是一个对象，对象中的属性发送了变化不会触发侦听器（可以使用对象类型的 <code>deep属性</code> 侦听器解决）</p>
</li>
</ol>
</li>
<li><p><strong>对象类型的侦听器</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">watch</span>:&#123;</span><br><span class="line">	<span class="comment">// 对象类型的侦听器</span></span><br><span class="line">	<span class="attr">username</span>: &#123;</span><br><span class="line">		<span class="title function_">handler</span>(<span class="params">newUsername, username</span>)&#123;</span><br><span class="line">			$.<span class="title function_">get</span>(<span class="string">&#x27;https://www.escook.cn/api/finduser/&#x27;</span> + newUsername, <span class="keyword">function</span>(<span class="params">res</span>) &#123;</span><br><span class="line">				<span class="variable language_">console</span>.<span class="title function_">log</span>(res);</span><br><span class="line">			&#125;)</span><br><span class="line">		&#125;,</span><br><span class="line">		<span class="comment">// 控制是否进入页面就立即触发 true false</span></span><br><span class="line">		<span class="attr">immediate</span>: <span class="literal">true</span>,</span><br><span class="line">        <span class="comment">//深度侦听</span></span><br><span class="line">        <span class="attr">deep</span>: <span class="literal">true</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="计算属性"><a href="#计算属性" class="headerlink" title="计算属性"></a>计算属性</h2><blockquote>
<p>计算属性是指通过一系列运算之后，最终得到的一个属性值，这个动态计算出来的属性值可以被模板结构或methods方法使用</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> vm = <span class="keyword">new</span> <span class="title class_">Vue</span>(&#123;</span><br><span class="line">	<span class="attr">el</span>: <span class="string">&#x27;app&#x27;</span>,</span><br><span class="line">	<span class="attr">data</span>: &#123;</span><br><span class="line">		<span class="attr">r</span>:<span class="number">0</span>,</span><br><span class="line">		<span class="attr">g</span>:<span class="number">0</span>,</span><br><span class="line">		<span class="attr">b</span>:<span class="number">0</span>,</span><br><span class="line">	&#125;,</span><br><span class="line">	<span class="attr">cmputed</span>: &#123;</span><br><span class="line">		<span class="title function_">rgb</span>(<span class="params"></span>)&#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="string">`rgb(<span class="subst">$&#123;<span class="variable language_">this</span>.r&#125;</span>, <span class="subst">$&#123;<span class="variable language_">this</span>.g&#125;</span>, <span class="subst">$&#123;<span class="variable language_">this</span>.b&#125;</span>)`</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>





</p></div></div><div class="post-footer"><div class="meta"><div class="info"><i class="fa fa-sun-o"></i><span class="date">2022-11-17</span><i class="fa fa-tag"></i><a class="tag" href="/tags/Vue/" title="Vue">Vue </a><span class="leancloud_visitors"></span><span>About 301 words, 1 min 0 sec  read</span></div></div></div></div><div class="post animated fadeInDown"><div class="post-title"><h3><a href="/2022/11/16/Vue-%E6%8C%87%E4%BB%A4%E4%B8%8E%E8%BF%87%E6%BB%A4%E5%99%A8/">Vue-指令与过滤器</a></h3></div><div class="post-content"><div class="card"><p><p>- </p>
<h2 id="指令与过滤器"><a href="#指令与过滤器" class="headerlink" title="指令与过滤器"></a>指令与过滤器</h2><h3 id="指令"><a href="#指令" class="headerlink" title="指令"></a>指令</h3><blockquote>
<p>指令：是vue为开发者提供的模板语法，用于辅助开发者渲染页面的基本结构</p>
</blockquote>
<p><strong>vue中的指令按照用途可以分为6大类：</strong></p>
<ul>
<li><p><strong>内容渲染指令</strong></p>
<ul>
<li><p>内容渲染指令用来辅助开发者渲染DOM元素的文本内容，常用的内容渲染指令有如下3个：</p>
<ul>
<li><p>v-text</p>
<ul>
<li><pre><code class="html">&lt;p v-text = &quot;username&quot;&gt;&lt;/p&gt;
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">  - **缺点：**</span><br><span class="line"></span><br><span class="line">    - **会覆盖标签内部原本的内容**</span><br><span class="line">    - **不能渲染html标签**</span><br><span class="line"></span><br><span class="line">- &#123;&#123;&#125;&#125;  插值表达式（Mustache）</span><br><span class="line"></span><br><span class="line">  - ```html</span><br><span class="line">     &lt;div id=&quot;app&quot;&gt;&#123;&#123; username &#125;&#125;&lt;/div&gt;</span><br></pre></td></tr></table></figure>
</code></pre>
</li>
<li><p><strong>缺点:不能渲染html标签</strong></p>
</li>
<li><p>插入的值发生变化,内容会跟着变化</p>
</li>
<li><p>使用v-once指令可以一次性的插值, 当数据改变时, 插值处的内容不会更新.</p>
</li>
<li><pre><code class="html">&lt;span v-once&gt;这个将不会改变: &#123;&#123; msg &#125;&#125;&lt;/span&gt;
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- v-html</span><br><span class="line"></span><br><span class="line">  - ```html</span><br><span class="line">    &lt;p v-html = &quot;info&quot;&gt;&lt;/p&gt;</span><br></pre></td></tr></table></figure>
</code></pre>
</li>
<li><p>可以渲染带有标签的字符串成HTML内容</p>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>属性绑定指令</strong></p>
<blockquote>
<p>注意: 插值表达式只能用在 内容渲染指令 </p>
</blockquote>
<ul>
<li><p><code>v-bind</code></p>
<ul>
<li><p>可以使用v-bind指令(缩写 : )对DOM节点中的属性进行动态绑定</p>
<ul>
<li>&#96;&#96;&#96;html<div id="app">
        <input type="text" v-bind:placeholder="tips">
        <img v-bind:src="photo" alt="images">
    </div>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- **事件绑定指令**</span><br><span class="line"></span><br><span class="line">  -  `v-on`</span><br><span class="line"></span><br><span class="line">    - 利用v-on指令对DOM节点进行事件绑定</span><br><span class="line"></span><br><span class="line">    - ```html</span><br><span class="line">      &lt;div id=&quot;app&quot;&gt;</span><br><span class="line">              &lt;p&gt;count 的值是 &#123;&#123;count&#125;&#125;&lt;/p&gt;</span><br><span class="line">              &lt;button @click=&quot;addCount(99)&quot;&gt;+1&lt;/button&gt;</span><br><span class="line">              &lt;button v-on:click=&quot;subCount&quot;&gt;-1&lt;/button&gt;</span><br><span class="line">          &lt;/div&gt;</span><br><span class="line">      </span><br><span class="line">      </span><br><span class="line">          &lt;!-- 导入vue文件 --&gt;</span><br><span class="line">          &lt;script src=&quot;./lib/vue-2.6.12.js&quot;&gt; &lt;/script&gt;</span><br><span class="line">      </span><br><span class="line">          &lt;!-- 创建vue的实例对象 --&gt;</span><br><span class="line">          &lt;script&gt;</span><br><span class="line">              const vm = new Vue(&#123;</span><br><span class="line">                  el: &#x27;#app&#x27;,</span><br><span class="line">                  data: &#123;</span><br><span class="line">                      count: 3,</span><br><span class="line">                  &#125;,</span><br><span class="line">                  methods: &#123;</span><br><span class="line">                      addCount (n) &#123;  </span><br><span class="line">                          vm.count += n</span><br><span class="line">                      &#125;,</span><br><span class="line">                      subCount() &#123;</span><br><span class="line">                          vm.count--</span><br><span class="line">                      &#125;</span><br><span class="line">                  &#125;</span><br><span class="line">              &#125;)</span><br><span class="line">          &lt;/script&gt;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>在vm实例中添加methods属性，定义事件</p>
</li>
<li><p>缩写@+绑定事件类型</p>
</li>
<li><p>$event 表示原本的事件对象e , 如需使用，可以作为参数传递进事件函数</p>
</li>
</ul>
</li>
<li><p><code>事件修饰符</code></p>
<ul>
<li>加在事件绑定的后面控制事件触发</li>
<li>@click.prevent 阻止默认行为（链接跳转，表单提交等）</li>
<li>@click.stop 阻止事件冒泡</li>
<li>@click.capture </li>
<li>@click.once</li>
<li>@click.self</li>
</ul>
</li>
<li><p><code>按键修饰符</code></p>
<ul>
<li>在监听键盘事件时，可以为键盘相关事件添加按键修饰符（@keyup.enter ,  @keyup.esc）</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>双向绑定指令</strong></p>
<ul>
<li><code>v-model</code><ul>
<li>用来辅助开发者在不操作DOM的前提下，快速获取表单内容</li>
<li>可以双向绑定数据（用户的输入改变，可以同时改变data中的数据，反之也是），v-bind只能实现单向绑定</li>
<li>配套的HTML标签<ul>
<li>input输入框</li>
<li>textarea</li>
<li>select</li>
</ul>
</li>
</ul>
</li>
<li>专用修饰符<ul>
<li><code>.number</code> : 将采集到的数据转为number ，如果不转换，默认为string</li>
<li><code>.trim</code> ： 自动过滤用户输入的首位空白字符</li>
<li><code>.lazy</code>：在 “change”  时而非 “input” 时更新，防抖，用户输入的时候不改变data中的数据，只在用户输入完成（失去焦点时）进行更改</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>条件渲染指令</strong></p>
<blockquote>
<p>用来辅助开发者按需控制DOM的显示与隐藏</p>
</blockquote>
<ul>
<li><code>v-if</code><ul>
<li>隐藏方式：动态删除或创建元素</li>
</ul>
</li>
<li><code>v-else if </code>, <code>v-else</code></li>
<li><code>v-show</code><ul>
<li>隐藏方式：修改标签的行内样式 <code>display: none</code></li>
</ul>
</li>
<li>频繁切换元素的显示状态，使用v-show性能更好</li>
<li>刚生成页面时，某些元素不需要展示，则使用v-if更好</li>
</ul>
</li>
<li><p><strong>列表渲染指令</strong></p>
<ul>
<li><p><code>v-for</code></p>
<ul>
<li><p>基于一个数组来玄幻渲染一个列表结构，需要使用<code>item in items</code>形式，其中 <code>items</code>是待循环的数组，<code>item</code>是被循环的每一项</p>
</li>
<li><p>&#96;&#96;&#96;html</p>
<ul id="app">
        <table class="table table-boder table-hover table-striped" >
            <thead>
                <th>索引</th>
                <th>ID</th>
                <th>姓名</th>
            </thead>
            <tbody>
                <tr v-for="(item, i) in list">
                    <td></td>
                    <td></td>
                    <td></td>
                </tr>
            </tbody>


<pre><code>    &lt;/table&gt;
&lt;/ul&gt;

&lt;script&gt;
    const vm = new Vue(&#123;
        el: &#39;#app&#39;,
        data: &#123;
            list : [
                &#123;id: 1, name: &#39;www&#39;&#125;,
                &#123;id: 2, name: &#39;hhh&#39;&#125;,
                &#123;id: 3, name: &#39;ddd&#39;&#125;,
            ]
        &#125;
    &#125;)
&lt;/script&gt;
</code></pre>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">    - v-for 还支持可选的第二个参数，当前项的索引，语法格式为`(item, index) in items`</span><br><span class="line"></span><br><span class="line">  - **需要注意的点**</span><br><span class="line"></span><br><span class="line">    - 只要用到了v-for指令，那么一定要绑定一个 :key 属性，而且尽量把id作为key的值</span><br><span class="line">    -  key只能是字符串或数字类型</span><br><span class="line">    - key不允许重复（必须具有唯一性）</span><br><span class="line">    - 使用index的值作为key的值没用任何意义</span><br><span class="line"></span><br><span class="line">### 过滤器</span><br><span class="line"></span><br><span class="line">&gt;过滤器是vue为开发者提供的功能，常用于文本的格式化。过滤器可以用在两个地方：插值表达式和v-bind属性绑定</span><br><span class="line">&gt;</span><br><span class="line">&gt;过滤器应该被添加在JavaScript表达式的尾部，由”管道符“进行调用</span><br><span class="line"></span><br><span class="line">```html</span><br><span class="line">&#123;&#123;message | capitaliza&#125;&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
</li>
<li><p>注意点</p>
<ul>
<li>要定义在filters节点下，本质是一个函数</li>
<li>在过滤器函数中，一定要由返回值</li>
<li>message 是capitaliza 过滤函数 的参数</li>
</ul>
</li>
</ul>
<h4 id="私有过滤器"><a href="#私有过滤器" class="headerlink" title="私有过滤器"></a>私有过滤器</h4><ul>
<li>在filters节点下定义的过滤器，称为”私有过滤器“，只能在当前vm实例所使用</li>
</ul>
<h4 id="全局过滤器"><a href="#全局过滤器" class="headerlink" title="全局过滤器"></a>全局过滤器</h4><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">vue.filter(&#x27;capitalize&#x27;, (str) =&gt; &#123;</span><br><span class="line">	</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<ul>
<li>第一个参数，是全局过滤器的名字</li>
<li>第二个参数，是全局过滤器的处理函数</li>
<li>如果全局过滤器和私有过滤器名字一致，此时按照就近原则，调用私有过滤器</li>
</ul>
<blockquote>
<p>可以连续调用多个过滤器</p>
</blockquote>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;&#123; message | xxx | YYY &#125;&#125;</span><br></pre></td></tr></table></figure>



<blockquote>
<p>过滤器的本质是 JS函数，可以接收参数，只能从第二个参数开始接收</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;&#123; message | <span class="title function_">filter</span>(arg1, arg2) &#125;&#125;</span><br><span class="line"></span><br><span class="line"><span class="title class_">Vue</span>.<span class="title function_">filter</span>(<span class="string">&#x27;filter&#x27;</span>, <span class="function">(<span class="params">message, arg1, arg2</span>) =&gt;</span> &#123;</span><br><span class="line"></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>



</p></div></div><div class="post-footer"><div class="meta"><div class="info"><i class="fa fa-sun-o"></i><span class="date">2022-11-16</span><i class="fa fa-tag"></i><a class="tag" href="/tags/Vue/" title="Vue">Vue </a><span class="leancloud_visitors"></span><span>About 1371 words, 4 min 34 sec  read</span></div></div></div></div><div class="post animated fadeInDown"><div class="post-title"><h3><a href="/2022/11/16/HTML-Form%E8%A1%A8%E5%8D%95%E8%AF%A6%E8%A7%A3/">HTML-Form表单详解</a></h3></div><div class="post-content"><div class="card"><p><h3 id="Form表单详解"><a href="#Form表单详解" class="headerlink" title="Form表单详解"></a>Form表单详解</h3><blockquote>
<p>在HTML中，form标签称为表单</p>
<p>表单在页面样式中不会产生任何影响，但是会影响页面的行为</p>
<p>可以将表单中的数据，使用指定的请求方式（get 或 post），提交到指定的服务器地址</p>
</blockquote>
<ul>
<li>主要有以下四个内容<ul>
<li>请求时机</li>
<li>请求方式</li>
<li>请求地址</li>
<li>发送的数据</li>
</ul>
</li>
</ul>
<h4 id="请求时机"><a href="#请求时机" class="headerlink" title="请求时机"></a>请求时机</h4><p>有两种情况都会导致form表单的提交</p>
<ul>
<li><p><strong>点击了表单中的提交按钮</strong></p>
<ul>
<li>提交按钮指的是，<code>type=&quot;submit&quot;</code>的按钮（不管是button还是input）。另外，<code>type=&quot;image&quot;</code>的<code>input</code>标签，也可以实现提交，也可以当做是提交按钮。</li>
<li>注意点：<ul>
<li>提交按钮必须放置在表单里面</li>
<li>点击提交按钮时，只提交它所在的表单</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>在 JS 中调用的表单对象的submit方法</strong></p>
<p>1、获取form表单的dom对象</p>
<p>2、为dom对象绑定事件</p>
<p>3、提交form表单</p>
</li>
</ul>
<h4 id="请求方式"><a href="#请求方式" class="headerlink" title="请求方式"></a>请求方式</h4><p>了解了form表单的提交时机，再来看它的请求方式</p>
<p>所谓请求方式，就是提交时将使用什么类型的请求（get、post）发送给服务器</p>
<p>使用form标签的method属性，可以控制form表单的提交方式，该属性可以省略，若省略，默认的提交方式是get</p>
<p>当使用get方式提交表单时，浏览器会将表单中的数据添加到地址后面，作为地址参数</p>
<p>下面的form表单使用了get的方式提交请求：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">action</span>=<span class="string">&quot;/server.php&quot;</span> <span class="attr">method</span>=<span class="string">&quot;get&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>账号：<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">name</span>=<span class="string">&quot;loginid&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>密码：<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;password&quot;</span> <span class="attr">name</span>=<span class="string">&quot;loginpwd&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span><span class="tag">&lt;<span class="name">button</span> <span class="attr">type</span>=<span class="string">&quot;submit&quot;</span>&gt;</span>提交<span class="tag">&lt;/<span class="name">button</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>当提交表单时，向服务器发送以下信息：</p>
<p>请求地址：&#x2F;server.php?loginid&#x3D;账号文本框内容&amp;loginpwd&#x3D;密码文本框内容</p>
<p>请求体：无</p>
<p>反之，如果使用post的方式提交请求：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">action</span>=<span class="string">&quot;/server.php&quot;</span> <span class="attr">method</span>=<span class="string">&quot;post&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>账号：<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">name</span>=<span class="string">&quot;loginid&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>密码：<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;password&quot;</span> <span class="attr">name</span>=<span class="string">&quot;loginpwd&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span><span class="tag">&lt;<span class="name">button</span> <span class="attr">type</span>=<span class="string">&quot;submit&quot;</span>&gt;</span>提交<span class="tag">&lt;/<span class="name">button</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>当提交表单时，则向服务器发送以下信息：</p>
<p>请求地址：&#x2F;server.php</p>
<p>请求体：loginid&#x3D;账号文本框内容&amp;loginpwd&#x3D;密码文本框内容</p>
<h4 id="请求地址"><a href="#请求地址" class="headerlink" title="请求地址"></a>请求地址</h4><p>表单中的请求地址是指，当提交form表单时，会将表单中的数据提交到服务的哪个地址去处理，就好比你去政府办事，你要把你的资料提交给哪个部门来处理</p>
<p>你可以使用form标签的<code>action</code>属性来设置其提交地址，该属性如果被省略，则默认为当前页面地址</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 当提交表单时，会将表单内容发送给/server.php这个地址处理 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">action</span>=<span class="string">&quot;/server.php&quot;</span> <span class="attr">method</span>=<span class="string">&quot;post&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>账号：<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">name</span>=<span class="string">&quot;loginid&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>密码：<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;password&quot;</span> <span class="attr">name</span>=<span class="string">&quot;loginpwd&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span><span class="tag">&lt;<span class="name">button</span> <span class="attr">type</span>=<span class="string">&quot;submit&quot;</span>&gt;</span>提交<span class="tag">&lt;/<span class="name">button</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h4 id=""><a href="#" class="headerlink" title=""></a></h4><h4 id="发送的数据"><a href="#发送的数据" class="headerlink" title="发送的数据"></a>发送的数据</h4><p>可以被表单发送的数据必须满足：</p>
<ul>
<li>具有name属性的标签</li>
<li>必须是**包含在form标签里的 ** <code>input</code>、<code>select</code>、<code>textarea</code>标签，其他标签不会提交到服务器</li>
</ul>
<p>提交数据时，键值对分别如下：</p>
<ul>
<li>键：标签的name属性值</li>
<li>值：标签的value属性值</li>
</ul>
<h4 id="-1"><a href="#-1" class="headerlink" title=""></a></h4></p></div></div><div class="post-footer"><div class="meta"><div class="info"><i class="fa fa-sun-o"></i><span class="date">2022-11-16</span><i class="fa fa-tag"></i><a class="tag" href="/tags/HTML/" title="HTML">HTML </a><span class="leancloud_visitors"></span><span>About 991 words, 3 min 18 sec  read</span></div></div></div></div><div class="post animated fadeInDown"><div class="post-title"><h3><a href="/2022/11/15/Vue-%E4%BD%BF%E7%94%A8/">Vue-使用</a></h3></div><div class="post-content"><div class="card"><p><h2 id="Vue的使用"><a href="#Vue的使用" class="headerlink" title="Vue的使用"></a>Vue的使用</h2><ul>
<li><p><strong>基本步骤</strong></p>
<ul>
<li>导入vue.js的script脚本文件</li>
<li>在页面中声明一个将要被Vue所控制的DOM区域</li>
<li>创建vm实例对象（vue实例对象）</li>
</ul>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">&quot;X-UA-Compatible&quot;</span> <span class="attr">content</span>=<span class="string">&quot;IE=edge&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;viewport&quot;</span> <span class="attr">content</span>=<span class="string">&quot;width=device-width, initial-scale=1.0&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Document<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- vue控制的div --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;app&quot;</span>&gt;</span>&#123;&#123; username &#125;&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 导入vue文件 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;./lib/vue-2.6.12.js&quot;</span>&gt;</span> <span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 创建vue的实例对象 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">        <span class="keyword">const</span> vm = <span class="keyword">new</span> <span class="title class_">Vue</span>(&#123;</span></span><br><span class="line"><span class="language-javascript">            <span class="attr">el</span>: <span class="string">&#x27;#app&#x27;</span>,</span></span><br><span class="line"><span class="language-javascript">            <span class="attr">data</span>: &#123;</span></span><br><span class="line"><span class="language-javascript">                username : <span class="string">&#x27;zs&#x27;</span></span></span><br><span class="line"><span class="language-javascript">            &#125;</span></span><br><span class="line"><span class="language-javascript">        &#125;)</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">    </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
</ul>
</p></div></div><div class="post-footer"><div class="meta"><div class="info"><i class="fa fa-sun-o"></i><span class="date">2022-11-15</span><i class="fa fa-tag"></i><a class="tag" href="/tags/Vue/" title="Vue">Vue </a><span class="leancloud_visitors"></span><span>About 187 words, 37 sec  read</span></div></div></div></div><div class="post animated fadeInDown"><div class="post-title"><h3><a href="/2022/11/15/Vue-%E7%89%B9%E6%80%A7/">Vue-特性</a></h3></div><div class="post-content"><div class="card"><p><h2 id="Vue-的特性"><a href="#Vue-的特性" class="headerlink" title="Vue 的特性"></a>Vue 的特性</h2><ul>
<li><p><strong>数据驱动视图</strong></p>
<ul>
<li>当页面数据发生变化时，页面会自动重新渲染</li>
<li>数据驱动试图时<strong>单项的数据绑定</strong></li>
<li>获取到数据之后，Vue可以监听到数据的变化，然后渲染页面（不需要频繁操作DOM）</li>
</ul>
</li>
<li><p><strong>双向数据绑定</strong></p>
<blockquote>
<p>在网页中，form表单负责采集数据，Ajax负责提交数据</p>
</blockquote>
<ul>
<li>在填写表单时，双向绑定可以辅助开发者在不操作DOM的前提下，自动把用户填写的内容同步到数据源中</li>
<li>js 数据的变化，会被自动渲染到页面上</li>
<li>页面上表单采集的数据发生变化的时候，会被vue自动获取并更新到js数据中</li>
</ul>
</li>
<li><p><strong>MVVM</strong></p>
<p>MVVM 是vue实现 数据驱动视图 和 双向数据绑定  的核心原理。 MVVM指的是Model、View和ViewModel，他把每个HTML页面都拆分成了三个部分</p>
<ul>
<li>Model：表示当前页面渲染时所依赖的数据源</li>
<li>View：表示当前页面所渲染的DOM结构</li>
<li>ViewModel：表示vue的实例（包含DOM listeners 和 Data Bindings）</li>
</ul>
</li>
<li><p>当数据源发生变化时，会被ViewModel监听到，VM会根据最新的数据源自动更新页面的结构</p>
</li>
<li><p>当表单元素的值发生变化时，也会被VM监听到，VM会把变化过后最新的值自动同步到Model数据源中</p>
</li>
<li><p><img src="https://ahuiyo.cn/Vue%E5%AD%A6%E4%B9%A0-MVVM%E6%A8%A1%E5%9E%8B/2.png" alt="Vue学习--MVVM模型| Ahuiyo のBlog"></p>
</li>
</ul>
</p></div></div><div class="post-footer"><div class="meta"><div class="info"><i class="fa fa-sun-o"></i><span class="date">2022-11-15</span><i class="fa fa-tag"></i><a class="tag" href="/tags/Vue/" title="Vue">Vue </a><span class="leancloud_visitors"></span><span>About 382 words, 1 min 16 sec  read</span></div></div></div></div><div class="post animated fadeInDown"><div class="post-title"><h3><a href="/2022/11/15/Vue-%E5%89%8D%E6%9C%9F%E5%87%86%E5%A4%87/">Vue-前期准备</a></h3></div><div class="post-content"><div class="card"><p><h3 id="实际的开发"><a href="#实际的开发" class="headerlink" title="实际的开发"></a>实际的开发</h3><ul>
<li><strong>模块化</strong>（JS 的模块化，css的模块化， 资源的模块化）</li>
<li><strong>组件化</strong>（复用现有的UI结构、样式、行为）</li>
<li><strong>规范化</strong>（目录结构的划分、编码规范化、接口规范化、文档规范化、Git分支管理）</li>
<li><strong>自动化</strong>（自动化构建、自动部署、自动化测试）</li>
</ul>
<h2 id="Webpack"><a href="#Webpack" class="headerlink" title="Webpack"></a>Webpack</h2><ul>
<li><p>概念：webpack是前端工程化的具体解决方案</p>
</li>
<li><p><strong>webpack</strong> 是一个用于现代 JavaScript 应用程序的 <em>静态模块打包工具</em>。当 webpack 处理应用程序时，它会在内部从一个或多个入口点构建一个 <a target="_blank" rel="noopener" href="https://webpack.docschina.org/concepts/dependency-graph/">依赖图(dependency graph)</a>，然后将你项目中所需的每一个模块组合成一个或多个 <em>bundles</em>，它们均为静态资源，用于展示你的内容。</p>
</li>
<li><p>主要功能：它提供了友好的前端模块化开发支持，以及代码压缩混淆，处理浏览器端JS的兼容性，性能优化等强大的功能</p>
</li>
</ul>
<h3 id="webpack基础"><a href="#webpack基础" class="headerlink" title="webpack基础"></a>webpack基础</h3><ul>
<li><p>在项目中安装webpack</p>
<ul>
<li>npm install <a href="mailto:&#119;&#101;&#98;&#112;&#97;&#x63;&#x6b;&#64;&#53;&#46;&#52;&#x32;&#x2e;&#x31;">&#119;&#101;&#98;&#112;&#97;&#x63;&#x6b;&#64;&#53;&#46;&#52;&#x32;&#x2e;&#x31;</a> <a href="mailto:&#119;&#x65;&#98;&#112;&#x61;&#x63;&#x6b;&#x2d;&#99;&#x6c;&#x69;&#x40;&#52;&#x2e;&#x37;&#46;&#x32;">&#119;&#x65;&#98;&#112;&#x61;&#x63;&#x6b;&#x2d;&#99;&#x6c;&#x69;&#x40;&#52;&#x2e;&#x37;&#46;&#x32;</a> –save-dev</li>
<li>-S 是 –save 的简写 （如果某个包在开发和部署之后都需要用到，则需要使用该命令安装到”dependencies”）</li>
<li>-D 是 –save-dev的jianxie （如果某个包只在开发过程中用到，则使用该命令安装到”devDependencies”）</li>
</ul>
</li>
<li><p>配置webpack</p>
<ul>
<li><p><strong>1、在项目根目录中，创建名为 webpack.config.js 的webpack配置文件，并初始化如下的基本配置:</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = &#123;</span><br><span class="line">	<span class="attr">mode</span>: <span class="string">&#x27;development&#x27;</span> <span class="comment">// mode 用来指定构建模式， 可选值有 development 和 production</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// development ： 追求打包速度，不是体积</span></span><br><span class="line"><span class="comment">// production，体积小，打包速度慢 不写mode默认为production</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>2、在 package.json 的 script 节点下，新增dev脚本如下：</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;scripts&quot;</span>: &#123;</span><br><span class="line">	<span class="string">&quot;dev&quot;</span>: <span class="string">&quot;webpack&quot;</span> <span class="comment">// script 节点下的脚本，可以通过npm run执行，例如 npm run dev</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>3、 在终端中运行 npm run dev命令，启动webpack 进行项目的打包构建</strong></p>
</li>
</ul>
</li>
</ul>
</p></div></div><div class="post-footer"><div class="meta"><div class="info"><i class="fa fa-sun-o"></i><span class="date">2022-11-15</span><i class="fa fa-tag"></i><a class="tag" href="/tags/Vue/" title="Vue">Vue </a><span class="leancloud_visitors"></span><span>About 555 words, 1 min 51 sec  read</span></div></div></div></div><div class="post animated fadeInDown"><div class="post-title"><h3><a href="/2022/11/15/XSS%E6%94%BB%E5%87%BB/">XSS攻击</a></h3></div><div class="post-content"><div class="card"><p><h3 id="什么是XSS攻击？"><a href="#什么是XSS攻击？" class="headerlink" title="什么是XSS攻击？"></a>什么是XSS攻击？</h3><blockquote>
<p>跨站脚本（Cross-site scripting，简称为：CSS, 但这会与层叠样式表（Cascading Style Sheets，CSS）的缩写混淆。因此，跨站脚本攻击缩写为XSS）是一种网站应用程序的安全漏洞攻击。</p>
<p>XSS攻击通常指的是通过利用网页开发时留下的漏洞，通过巧妙的方法注入恶意指令代码到网页，使用户加载并执行攻击者恶意制造的网页程序。这些恶意网页程序通常是JavaScript，但实际上也可以包括Java、 VBScript、 LiveScript、ActiveX、 Flash 或者甚至是普通的HTML。攻击成功后，攻击者可能得到包括但不限于更高的权限（如执行一些操作）、私密网页内容、会话和cookie等各种内容。</p>
</blockquote>
<h3 id="XSS攻击类型"><a href="#XSS攻击类型" class="headerlink" title="XSS攻击类型"></a>XSS攻击类型</h3><blockquote>
<p>最常见的几种分类：<strong>反射型（非持久型）XSS</strong>、<strong>存储型（持久型）XSS</strong>、<strong>DOM型XSS</strong>、<strong>通用型XSS</strong>、<strong>突变型XSS</strong>。</p>
</blockquote>
<ul>
<li>反射型攻击<ul>
<li><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b53bf56086cd48988872c80c6db8f5ba~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.image" alt="img"></li>
<li>将恶意链接传入发送给用户，诱导用户点击恶意链接，访问目标服务器，在得到目标服务器返回的数据之后，用户会解析数据（含有恶意URL），访问攻击者事先设置好的恶意服务器，使得攻击者得到用户数据</li>
<li>主要场景有以下几种：<ul>
<li>将不可信数据插入到HTML标签之间时；&#x2F;&#x2F; 例如div, p, td；</li>
<li>将不可信数据插入到HTML属性里时；&#x2F;&#x2F; 例如：<code>&lt;div width=$INPUT&gt;&lt;/div&gt;</code></li>
<li>将不可信数据插入到SCRIPT里时；&#x2F;&#x2F; 例如：<code>&lt;script&gt;var message = ” $INPUT “;&lt;/script&gt;</code></li>
<li>还有插入到Style属性里的情况，同样具有一定的危害性；&#x2F;&#x2F; 例如<code>&lt;span style=” property : $INPUT ”&gt;&lt;/span&gt;</code></li>
<li>将不可信数据插入到HTML URL里时，&#x2F;&#x2F; 例如：<code>&lt;a href=”[http://www.abcd.com?param=](http://www.ccc.com/?param=) $INPUT ”&gt;&lt;/a&gt;</code></li>
<li>使用富文本时，没有使用XSS规则引擎进行编码过滤。</li>
</ul>
</li>
</ul>
</li>
<li>存储型攻击（ HTML 注入型&#x2F;持久型）<ul>
<li><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/43b345fe21ab461b83c59dd304499851~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.image" alt="img"></li>
<li>直接将恶意脚本输入到服务器中保存下来，使得其它用户（前端）和管理员（前后端）在访问资源时执行了恶意代码，用户访问服务器-跨站链接-返回跨站代码。</li>
</ul>
</li>
<li>DOM型XSS</li>
<li>通用型XSS</li>
</ul>
<h3 id="预防XSS攻击"><a href="#预防XSS攻击" class="headerlink" title="预防XSS攻击"></a>预防XSS攻击</h3><p><strong>XSS 攻击有两大要素： 1. 攻击者提交恶意代码。 2. 浏览器执行恶意代码。</strong></p>
<h4 id="1-预防-DOM-型-XSS-攻击"><a href="#1-预防-DOM-型-XSS-攻击" class="headerlink" title="1.预防 DOM 型 XSS 攻击"></a>1.预防 DOM 型 XSS 攻击</h4><p>DOM 型 XSS 攻击，实际上就是网站前端 JavaScript 代码本身不够严谨，把不可信的数据当作代码执行了。</p>
<p>在使用 <code>.innerHTML、.outerHTML、document.write() </code>时要特别小心，不要把不可信的数据作为 HTML 插到页面上，而应尽量使用<code> .textContent、.setAttribute()</code> 等。</p>
<p>DOM 中的内联事件监听器，如 <code>location、onclick、onerror、onload、onmouseover </code>等， 标签的<code>href</code>属性，JavaScript 的<code>eval()、setTimeout()、setInterval()</code>等，都能把字符串作为代码运行。如果不可信的数据拼接到字符串中传递给这些 API，很容易 产生安全隐患，请务必避免。</p>
<h4 id="2-输入过滤"><a href="#2-输入过滤" class="headerlink" title="2.输入过滤"></a>2.输入过滤</h4><p>如果由前端过滤输入，然后提交到后端的话。一旦攻击者绕过前端过滤，直接构造请求，就可以提交恶意代码了。</p>
<p>那么，换一个过滤时机：后端在写入数据库前，对输入进行过滤，然后把“安全的”内容，返回给前端。这样是否可行呢？ 我们举一个例子，一个正常的用户输入了 5 &lt; 7 这个内容，在写入数据库前，被转义，变成了 5 <code>$lt;</code> 7。 问题是：在提交阶段，我们并不确定内容要输出到哪里。</p>
<p>这里的“并不确定内容要输出到哪里”有两层含义：</p>
<ol>
<li>用户的输入内容可能同时提供给前端和客户端，而一旦经过了 escapeHTML()，客户端显示的内容就变成了乱码( 5 <code>$lt;</code>7 )。</li>
<li>在前端中，不同的位置所需的编码也不同。 当 5 <code>$lt;</code>7  作为 HTML 拼接页面时，可以正常显示：<code>5 &lt; 7</code></li>
</ol>
<p>所以输入过滤非完全可靠，我们就要通过“防止浏览器执行恶意代码”来防范 XSS，可采用下面的两种方法</p>
<h4 id="3-前端渲染把代码和数据分隔开"><a href="#3-前端渲染把代码和数据分隔开" class="headerlink" title="3.前端渲染把代码和数据分隔开"></a>3.前端渲染把代码和数据分隔开</h4><p>在前端渲染中，我们会明确的告诉浏览器：下面要设置的内容是文本（.innerText），还是属性（.setAttribute），还是样式 （.style）等等。浏览器不会被轻易的被欺骗，执行预期外的代码了。</p>
<ul>
<li>Javascript：可以使用textContent或者innerText的地方，尽量不使用innerHTML；</li>
<li>query：可以使用text()得地方，尽量不使用html()；</li>
</ul>
<h4 id="4-拼接HTML时对其进行转义"><a href="#4-拼接HTML时对其进行转义" class="headerlink" title="4.拼接HTML时对其进行转义"></a>4.拼接HTML时对其进行转义</h4><p>如果拼接 HTML 是必要的，就需要采用合适的转义库，对 HTML 模板各处插入点进行充分的转义。</p>
<p>常用的模板引擎，如 doT.js、ejs、FreeMarker 等，对于 HTML 转义通常只有一个规则，就是把 &amp; &lt; &gt; “ ‘ &#x2F; 这几个字符转义掉，确 实能起到一定的 XSS 防护作用，但并不完善：</p>
<p>这里推荐一个前端防止XSS攻击的插件: <a target="_blank" rel="noopener" href="https://juejin.cn/post/6913344728515739661">js-xss的使用和源码解读</a>，Git 3.8K 的Star和60W的周下载量证明了其强大性.</p>
</p></div></div><div class="post-footer"><div class="meta"><div class="info"><i class="fa fa-sun-o"></i><span class="date">2022-11-15</span><i class="fa fa-tag"></i><a class="tag" href="/tags/计算机知识杂烩/" title="计算机知识杂烩">计算机知识杂烩 </a><span class="leancloud_visitors"></span><span>About 1502 words, 5 min 0 sec  read</span></div></div></div></div><div class="post animated fadeInDown"><div class="post-title"><h3><a href="/2022/11/12/webpack-%E5%A6%82%E4%BD%95%E5%88%A0%E9%99%A4%E9%A1%B9%E7%9B%AE%E5%A4%9A%E4%BD%99%E6%96%87%E4%BB%B6/">webpack-如何删除项目多余文件</a></h3></div><div class="post-content"><div class="card"><p><h2 id="删除项目多余文件"><a href="#删除项目多余文件" class="headerlink" title="删除项目多余文件"></a>删除项目多余文件</h2><p>项目迭代会产生多余的功能或者弃用的功能，针对此类功能，大多数是将入口关闭，或者注释掉部分代码，但是依赖的文件（js&#x2F;css&#x2F;png&#x2F;jpg等）并没有删除掉。</p>
<p>删除项目多余文件的操作有：</p>
<ul>
<li><p>使用useless-files-webpack-plugin插件</p>
<ul>
<li><p>安装</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm i useless-files-webpack-plugin -D</span><br></pre></td></tr></table></figure>

<ul>
<li>在 webpack.config.js中添加</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title class_">UselessFile</span> = <span class="built_in">require</span>(<span class="string">&#x27;useless-files-webpack-plugin&#x27;</span>);</span><br></pre></td></tr></table></figure>

<ul>
<li>在plugins 中添加插件配置</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="title class_">UselessFile</span>(&#123;</span><br><span class="line">    <span class="attr">root</span>: <span class="string">&#x27;./src&#x27;</span>, <span class="comment">// 项目目录</span></span><br><span class="line">    <span class="attr">out</span>: <span class="string">&#x27;./fileList.json&#x27;</span>, <span class="comment">// 输出文件列表</span></span><br><span class="line">    <span class="comment">// out: (files) =&gt; deal(files), // 或者回调处理</span></span><br><span class="line">    <span class="attr">clean</span>: <span class="literal">false</span> <span class="comment">// 删除文件,</span></span><br><span class="line">    <span class="attr">exclude</span>: path <span class="comment">// 排除文件列表, 格式为文件路径数组</span></span><br><span class="line">&#125;),</span><br><span class="line"></span><br></pre></td></tr></table></figure>
</li>
<li><p>使用webpack打包时，会在根目录下生成 unused-files.json文件，保存着无用文件列表</p>
</li>
<li><p>根据列表中的提供路径，核对相应文件是否需要保留。无需保留，手动删除即可。</p>
</li>
</ul>
</li>
</ul>
</p></div></div><div class="post-footer"><div class="meta"><div class="info"><i class="fa fa-sun-o"></i><span class="date">2022-11-12</span><i class="fa fa-tag"></i><a class="tag" href="/tags/webpack/" title="webpack">webpack </a><span class="leancloud_visitors"></span><span>About 258 words, 51 sec  read</span></div></div></div></div><div class="pagination"><ul class="clearfix"><li class="next pagbuttons"><a class="btn" role="navigation" href="/page/2/">Next</a></li></ul></div></div></div></div><script src="/js/jquery-migrate-1.2.1.min.js"></script><script src="/js/jquery.appear.js"></script><script src="/js/add-bookmark.js"></script><script>(function(window){var INSIGHT_CONFIG={TRANSLATION:{POSTS:"Posts",PAGES:"Pages",CATEGORIES:"Categories",TAGS:"Tags",UNTITLED:"(Untitled)",},CONTENT_URL:"/content.json",};window.INSIGHT_CONFIG=INSIGHT_CONFIG})(window);</script><script src="/js/insight.js" defer></script><div class="searchbox ins-search"><div class="searchbox-container ins-search-container"><div class="searchbox-input-wrapper"><input class="searchbox-input ins-search-input" type="text" placeholder="Search..."><span class="searchbox-close"><a class="fa fa-times-circle" onclick="closeWindow();"></a></span></div><div class="searchbox-result-wrapper ins-section-wrapper"><div class="ins-section-container"><p>Seraching...</p></div></div></div></div></body></html>