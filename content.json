{"pages":[],"posts":[{"title":"CSS tips","text":"精灵图精灵图使用步骤： ​ 1 创建一个盒子，设置盒子的尺寸和小图尺寸相同 ​ 2 将精灵图设置为盒子的背景图片 ​ 3 修改背景图位置 ​ 通过pxcood 测量小图片左上角坐标， 分别取负值设置给盒子的 background-position : x y 过渡 作用：让元素的样式慢慢的变化，常配合hover使用，增强网页交互体验 属性名： transition 常见取值： ​ 过渡的属性 – all（所有能过渡的属性都过渡、具体属性名如：width：只有width有过度） ​ 过渡的时长 – 数字+s 注意点： ​ 过渡需要：默认状态和hover状态样式不同，才能有过渡效果 ​ transition属性给需要过渡的元素本身加 ​ transition属性设置在不同状态中，效果不同 ​ 1 给默认状态设置，鼠标移入移出都有过渡效果 ​ 2 给hover状态设置，鼠标移入有过渡效果，移出没有过渡效果 文件和目录准备 新建项目文件夹 项目名(英文)-pc-client，在VScode中打开 在实际开发中，项目文件夹不建议使用中文 所有项目相关文件都保存在项目名(英文)-pc-client目录中 复制favicon.ico (网页标题图标)到项目名(英文)-pc-client目录 一般习惯将ico图标放在项目根目录 复制 image 和 uploads目录到项目名(英文)-pc-client目录中 image：存放网站固定使用的图片素材，如：logo、样式修饰图片等等 uploads： 存放网站非固定使用的图片素材，如：商品图片、宣传图片等 新建 index.html 在根目录 新建css文件夹保存网站的样式，并新建以下css文件： base.css: 基础公共样式 common.css: 该网站中多个网页相同模块的重复样式，如：头部、底部 index.css：首页样式","link":"/2022/09/21/CSS-tips/"},{"title":"Hello World","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new &quot;My New Post&quot; More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","link":"/2022/09/21/hello-world/"},{"title":"发博操作","text":"将博客部署到GitHub上： 1234hexo cleanhexo generate(若要本地预览就先执行 hexo server)hexo deploy 快捷命令： 1234hexo g == hexo generatehexo d == hexo deployhexo s == hexo serverhexo n == hexo new 还能组合使用，如： 1hexo d -g 创建新文本文档 1hexo new &quot;文件名称&quot;","link":"/2022/09/21/%E5%8F%91%E5%8D%9A%E6%93%8D%E4%BD%9C/"},{"title":"JS-数据类型","text":"数据类型 基本（值）类型 String : 任意字符串 Number ： 任意的数字 Boolean ： true false undefined ： 未定义的值。表示一个变量最原始的状态，而非人为操作的结果。 这种原始状态会在以下 4 种场景中出现： 1、声明一个变量，但是没有赋值123var foo;console.log(foo); // undefined复制代码 访问 foo，返回了 undefined，表示这个变量自从声明了以后，就从来没有使用过，也没有定义过任何有效的值。 2、访问对象上不存在的属性或者未定义的变量123console.log(Object.foo); // undefinedconsole.log(typeof demo); // undefined复制代码 访问 Object 对象上的 foo 属性，返回 undefined ， 表示Object 上不存在或者没有定义名为 foo 的属性；对未声明的变量执行typeof操作符返回了undefined值。 3、函数定义了形参，但没有传递实参123456//函数定义了形参 afunction fn(a) { console.log(a); // undefined}fn(); //未传递实参复制代码 函数 fn 定义了形参 a，但 fn 被调用时没有传递参数，因此，fn 运行时的参数 a 就是一个原始的、未被赋值的变量。 4、使用void对表达式求值123456void 0 ; // undefinedvoid false; // undefinedvoid []; // undefinedvoid null; // undefinedvoid function fn(){} ; // undefined复制代码 ECMAScript 明确规定 void 操作符 对任何表达式求值都返回 undefined ，这和函数执行操作后没有返回值的作用是一样的，JavaScript 中的函数都有返回值，当没有 return 操作时，就默认返回一个原始的状态值，这个值就是 undefined，表明函数的返回值未被定义。 因此，undefined 一般都来自于某个表达式最原始的状态值，不是人为操作的结果。当然，你也可以手动给一个变量赋值 undefined，但这样做没有意义，因为一个变量不赋值就是 undefined 。 null ： 空值，表示一个对象被人为的重置为空对象，而非一个变量最原始的状态。在内存里的表示就是，栈中的变量没指向堆中的内存对象。 1、一般在以下两种情况下我们会将变量赋值为null 如果定义的变量在将来用于保存对象，那么最好将该变量初始化为null，而不是其他值。换句话说，只要意在保存对象的变量还没有真正保存对象，就应该明确地让该变量保存null值，这样有助于进一步区分null和undefined。 当一个数据不再需要使用时，我们最好通过将其值设置为null来释放其引用，这个做法叫做解除引用。不过解除一个值的引用并不意味着自动回收改值所占用的内存。解除引用的真正作用是让值脱离执行环境，以便垃圾收集器在下次运行时将其回收。解除引用还有助于消除有可能出现的循环引用的情况。这一做法适用于大多数全局变量和全局对象的属性，局部变量会在它们离开执行环境时(函数执行完时)自动被解除引用。 2、特殊的typeof null当我们使用typeof操作符检测null值，我们理所应当地认为应该返”Null”类型呀，但是事实返回的类型却是”object”。 123var data = null;console.log(typeof data); // &quot;object&quot;复制代码 是不是很奇怪？其实我们可以从两方面来理解这个结果: 一方面从逻辑角度来看，null值表示一个空对象指针，它代表的其实就是一个空对象，所以使用typeof操作符检测时返回”object”也是可以理解的。 另一方面，其实在JavaScript 最初的实现中，JavaScript 中的值是由一个表示类型的标签和实际数据值表示的(对象的类型标签是 0)。由于 null 代表的是空指针（大多数平台下值为 0x00），因此，null的类型标签也成为了 0，typeof null就错误的返回了”object”。在ES6中，当时曾经有提案为历史平凡, 将type null的值纠正为null, 但最后提案被拒了,所以还是保持”object”类型。 对象（引用）类型 Object ： 任意对象 Function ： 函数（一种特别的对象） Array ： 数组 (内部数据是有序的) 判断 typeof 可以判断 ： undefined | 数值 | 字符串 | 布尔值 | function 不能判断： null 和 object | array 和 object instanceof : 判断对象的具体类型 === 可以判断undefined, null","link":"/2022/09/23/JS-%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/"},{"title":"JavaScript核心Web APIs[1]","text":"Web APIs Web APIs是W3C组织的标准 Web APIs 主要学习DOM 和 BOM Web APIs 是JS所独有的部分 主要学习页面交互功能 需要JS基础 APIAPI 是一些预先定义的函数，目的是提供应用程序与开发人员基于某软件或硬件得以访问一组例程的能力，而又无需访问源码。 Web APIweb API 是浏览器提供的一套操作浏览器功能和页面元素的API（BOM 和 DOM）。 DOM文档对象模型 （Document Object Model， 简称DOM）， 是W3C组织推荐的处理可扩展标记语言（HTML 或者 XML） 的标准编程接口。 DOM树 文档：一个页面一个文档，DOM使用document表示 元素：页面中的所有标签都是元素，DOM中使用element表示 节点： 网页中所有内容都是节点（标签、属性、文本、注释等），DOM中使用node表示 以上内容都看作对象 获取元素 根据ID获取 使用 getElementById() 方法获取 Document的方法 getElementById()返回一个匹配特定 ID的元素。由于元素的 ID 在大部分情况下要求是独一无二的，这个方法自然而然地成为了一个高效查找特定元素的方法。 如果需要查找到那些没有 ID 的元素，你可以考虑通过 CSS 选择器使用 querySelector()。 语法 1var element = document.getElementById(id); Copy to Clipboard 参数 **element**是一个 Element 对象。如果当前文档中拥有特定 ID 的元素不存在则返回 null. **id**是大小写敏感的字符串，代表了所要查找的元素的唯一 ID. 返回值 返回一个匹配到 ID 的 DOM Element 对象。若在当前 Document 下没有找到，则返回 null。 根据标签名获取 使用getElementsTagName()方法返回带有指定标签名的对象的集合（以伪数组的形式存储）。 获取某个元素（父元素）内部所有指定标签名的子元素 1element.getElementsByTagName('标签名') 注意：父元素必须是单个对象（必须指明是哪一个元素对象）。获取的时候不包括父元素自己 通过HTML5新增的方法获取 document.getElementsByClassName('类名');// 根据类名返回元素对象集合 1234567- ```javascript document.querySelector(&quot;.类名&quot;); // 返回指定选择器的第一个元素对象 // . 类名 // # id名 element = document.querySelector(selectors); document.querySelectorAll(&quot;&quot;); //返回指定选择器的所有对象的集合 12345- **特殊元素获取** - ```javascript document.body; \\\\获取body document.documentElement; \\\\获取html 1234567891011121314151617181920212223- ​ **事件基础** - 事件是可被 JS 检测到的行为 - 事件三部分： 事件源 事件类型 事件处理程序 - 事件源： 事件被触发的对象 按钮 - 事件类型： 如何触发 什么事件 - 事件处理程序 ： 通过一个函数赋值的方式完成 - 执行事件的步骤 - 获取事件源 - 注册事件（绑定事件） - 添加事件处理程序（采取函数赋值形式）- **操作元素** - 改变元素内容 - ```javascript //从起始位置到终止位置的内容，但它去除html标签，同时空格和换行也会去掉 element.innerText //起始位置到终止位置的全部内容，包括html标签，同时保留空格和换行 element.innerHTML innerText 不识别html的标签 （非标准） innerHTML 识别html标签 （w3c 标准） 以上可以获取标签内容 ```javascript事件源.innerText; // 会去除空格和换行 事件源.innerHTML; // 不去除换行和空格 12345- 改变表单元素的属性操作 - ```javascript 事件元素.属性 = &quot;修改后的&quot;； 利用DOM可以操作如下表单元素的属性： type、value、checked、selected、disableJad","link":"/2022/09/26/JavaScript%E6%A0%B8%E5%BF%83Web-APIs-1/"},{"title":"【Leedcode题目总结】-76.最小覆盖子串","text":"【Leedcode题目总结】-76.最小覆盖子串1234给你一个字符串 s 、一个字符串 t 。返回 s 中涵盖 t 所有字符的最小子串。如果 s 中不存在涵盖 t 所有字符的子串，则返回空字符串 &quot;&quot; 。注意：对于 t 中重复字符，我们寻找的子字符串中该字符数量必须不少于 t 中该字符数量。如果 s 中存在这样的子串，我们保证它是唯一的答案。 思路： 使用 map 和 滑动窗口 定义两个map need(用来存放t中字符以及对应的数目)， window（存放当前窗口包含t中的字符和数目） 定义 变量valid（表示window中满足need的数目），当vaid==need.size时，更新最小长度以及起始位置同时开始滑动窗口，滑动时更新vaild以及window。 代码 123456789101112131415161718192021222324252627282930313233343536373839/** * @param {string} s * @param {string} t * @return {string} */var minWindow = function(s, t) { // 定义两个map 分别用来统计 t的字符种类和数目， 当前窗口中包含t的字符种类和数目 const need = new Map(); const window = new Map(); for(let c of t) { need.set(c, need.has(c) ? need.get(c) + 1 : 1); } let left = 0, right = 0; let valid = 0; let start = 0, len = 100001; while(right &lt; s.length) { let c = s[right]; right++; if(need.has(c)) { window.set(c, window.has(c) ? window.get(c) + 1 : 1); if(window.get(c) === need.get(c)) valid++; } // 当满足条件的字符够了的时候进行滑动 while(valid === need.size) { if(right - left &lt; len) { start = left; len = right - left; } let d = s[left]; left++; if(need.has(d)) { if(window.get(d) === need.get(d)) valid--; window.set(d, window.get(d) - 1); } } } return len === 100001 ? '' : s.substr(start, len);}; 注意： 声明map的方式 set时不可以使用自加，自减 变量作为map索引时不需要加 ’ ‘，常量作为索引需要加","link":"/2022/09/30/%E3%80%90Leedcode%E9%A2%98%E7%9B%AE%E6%80%BB%E7%BB%93%E3%80%91-76-%E6%9C%80%E5%B0%8F%E8%A6%86%E7%9B%96%E5%AD%90%E4%B8%B2/"},{"title":"回流 & 重绘 （Reflow & Repaint）","text":"相关知识点1、浏览器使用流式布局模型（Flow Based Layout）网页布局中包括:静态布局，流式布局，响应式布局和弹性布局几种情况。 静态布局：指的就是网页中的所有元素都使用px为单位。不管浏览器具体的大小是多少，始终按照设置的值布局来显示，由于浏览器大小不一，这样的布局很容易在不同设备中出现滚动条等问题。所以这种布局在移动开发不是主流的布局方式。 流式布局：是页面中元素的宽度按照屏幕分辨率自动进行适配调整，也就是我们常说的适配，它可以保证当前屏幕分辨率发生改变的时候，页面中的元素大小也可以跟着改变，所以流式布局是移动端开发常用的一种布局。 2、浏览器会把HTMl解析成DOM，把CSS解析成CSSOM，DOM和CSSOM合并产生Render Tree（渲染树）3、通过Render Tree 可以知道所有节点的样式，然后计算他们在页面上的大小和位置，最后把节点绘制到页面上4、流式布局对Render Tree 只需要一次遍历就可以计算完成，但table及其内部元素除外，他们可能需要多次计算，通常需要花三倍于同等元素的时间，这也是为什么要避免使用table布局的原因之一。回流必将引起重绘，重绘不一定会引起回流 回流（Reflow）当Render Tree中部分或全部元素的尺寸、结构、或某些属性发生改变时，浏览器重新渲染部分或全部文档的过程称为回流。 会导致回流的操作： 页面首次渲染 浏览器窗口大小发生改变 元素尺寸或位置发生改变 元素内容变化（文字数量或图片大小等等） 元素字体大小变化 添加或者删除可见的DOM元素 激活CSS伪类（例如：:hover） 查询某些属性或调用某些方法 一些常用且会导致回流的属性和方法： clientWidth、clientHeight、clientTop、clientLeft offsetWidth、offsetHeight、offsetTop、offsetLeft scrollWidth、scrollHeight、scrollTop、scrollLeft scrollIntoView()、scrollIntoViewIfNeeded() getComputedStyle() getBoundingClientRect() scrollTo() 重绘（Repaint） 当页面中元素样式的改变并不影响它在文档流中的位置时（例如：color、background-color、visibility等），浏览器会将新样式赋予给元素并重新绘制它，这个过程称为重绘。 性能影响回流比重绘的代价要更高。 有时即使仅仅回流一个单一的元素，它的父元素以及任何跟随它的元素也会产生回流。 现代浏览器会对频繁的回流或重绘操作进行优化： 浏览器会维护一个队列，把所有引起回流和重绘的操作放入队列中，如果队列中的任务数量或者时间间隔达到一个阈值的，浏览器就会将队列清空，进行一次批处理，这样可以把多次回流和重绘变成一次。 当你访问以下属性或方法时，浏览器会立刻清空队列： clientWidth、clientHeight、clientTop、clientLeft offsetWidth、offsetHeight、offsetTop、offsetLeft scrollWidth、scrollHeight、scrollTop、scrollLeft width、height getComputedStyle() getBoundingClientRect() 因为队列中可能会有影响到这些属性或方法返回值的操作，即使你希望获取的信息与队列中操作引发的改变无关，浏览器也会强行清空队列，确保你拿到的值是最精确的。 如何避免CSS 避免使用table布局。 尽可能在DOM树的最末端改变class。 避免设置多层内联样式。 将动画效果应用到position属性为absolute或fixed的元素上。 避免使用CSS表达式（例如：calc()）。 JavaScript 避免频繁操作样式，最好一次性重写style属性，或者将样式列表定义为class并一次性更改class属性。 避免频繁操作DOM，创建一个documentFragment，在它上面应用所有DOM操作，最后再把它添加到文档中。 也可以先为元素设置display: none，操作结束后再把它显示出来。因为在display属性为none的元素上进行的DOM操作不会引发回流和重绘。 避免频繁读取会引发回流/重绘的属性，如果确实需要多次使用，就用一个变量缓存起来。 对具有复杂动画的元素使用绝对定位，使它脱离文档流，否则会引起父元素及后续元素频繁回流。","link":"/2022/09/30/%E5%9B%9E%E6%B5%81-%E9%87%8D%E7%BB%98-%EF%BC%88Reflow-Repaint%EF%BC%89/"},{"title":"DOM事件流","text":"DOM文档对象模型 （Document Object Model， 简称DOM）， 是W3C组织推荐的处理可扩展标记语言（HTML 或者 XML） 的标准编程接口。 DOM树 文档：一个页面一个文档，DOM使用document表示 元素：页面中的所有标签都是元素，DOM中使用element表示 节点： 网页中所有内容都是节点（标签、属性、文本、注释等），DOM中使用node表示 以上内容都看作对象 获取元素 根据ID获取 使用 getElementById() 方法获取 Document的方法 getElementById()返回一个匹配特定 ID的元素。由于元素的 ID 在大部分情况下要求是独一无二的，这个方法自然而然地成为了一个高效查找特定元素的方法。 如果需要查找到那些没有 ID 的元素，你可以考虑通过 CSS 选择器使用 querySelector()。 语法 1var element = document.getElementById(id); Copy to Clipboard 参数 **element**是一个 Element 对象。如果当前文档中拥有特定 ID 的元素不存在则返回 null. **id**是大小写敏感的字符串，代表了所要查找的元素的唯一 ID. 返回值 返回一个匹配到 ID 的 DOM Element 对象。若在当前 Document 下没有找到，则返回 null。 根据标签名获取 使用getElementsTagName()方法返回带有指定标签名的对象的集合（以伪数组的形式存储）。 获取某个元素（父元素）内部所有指定标签名的子元素 1element.getElementsByTagName('标签名') 注意：父元素必须是单个对象（必须指明是哪一个元素对象）。获取的时候不包括父元素自己 通过HTML5新增的方法获取 document.getElementsByClassName('类名');// 根据类名返回元素对象集合 1234567- ```javascript document.querySelector(&quot;.类名&quot;); // 返回指定选择器的第一个元素对象 // . 类名 // # id名 element = document.querySelector(selectors); document.querySelectorAll(&quot;&quot;); //返回指定选择器的所有对象的集合 12345- **特殊元素获取** - ```javascript document.body; \\\\获取body document.documentElement; \\\\获取html 1234567891011121314151617181920212223- ​ **事件基础** - 事件是可被 JS 检测到的行为 - 事件三部分： 事件源 事件类型 事件处理程序 - 事件源： 事件被触发的对象 按钮 - 事件类型： 如何触发 什么事件 - 事件处理程序 ： 通过一个函数赋值的方式完成 - 执行事件的步骤 - 获取事件源 - 注册事件（绑定事件） - 添加事件处理程序（采取函数赋值形式）- **操作元素** - 改变元素内容 - ```javascript //从起始位置到终止位置的内容，但它去除html标签，同时空格和换行也会去掉 element.innerText //起始位置到终止位置的全部内容，包括html标签，同时保留空格和换行 element.innerHTML innerText 不识别html的标签 （非标准） innerHTML 识别html标签 （w3c 标准） 以上可以获取标签内容 ```javascript事件源.innerText; // 会去除空格和换行 事件源.innerHTML; // 不去除换行和空格 12345- 改变表单元素的属性操作 - ```javascript 事件元素.属性 = &quot;修改后的&quot;； 利用DOM可以操作如下表单元素的属性： type、value、checked、selected、disableJad 修改样式属性（修改CSS） 通过JS修改元素的大小、颜色、位置等样式 ```javascriptelement.style \\行内样式操作element.className \\类名样式操作 12345678910- 如果样式修改较多，可以采取操作类名方式更改元素样式- class因为是个保留字，因此使用className来操作元素类名属性- className会直接更改元素的类名，会覆盖原先的类名 - ``` 如果想要保留原先类名 this.className = '原先类名 新类名'； 排他思想 如果有同一组元素，我们想要某一个元素实现某种样式，需要用到循环的排他思想算法： 所有元素全部清除样式 给当前元素设置样式 注意顺序不能颠倒，首先干掉其他人，再设置自己 自定义属性的操作 获取元素 element.属性 element.getAttribute('属性') 12345678910 - 两者区别 - element.属性 获取内置属性值（元素本身自带的属性） - element.getAttribute('属性') 主要获得自定义属性（标准）- 设置属性值 - ```javascript element.属性 = 'value'; ```javascriptelement.setAttribute(‘属性’， ‘value’); 12345678910111213- 主要目的 - 为了保存并使用数据。有些数据可以保存到页面中不需要保存到数据库中。- 设置H5自定义属性 - H5规定自定义属性data-开头作为属性名并且赋值- H5新增的获取自定义属性的方法 ```javascript document.dataset.属性名称； 如果自定义属性有多个 ’-‘ 链接的单词，获取时采取驼峰命名法 123data-list-nameconsole.log(div.dataset['listName']); 节点操作 利用节点层级关系获取元素 利用父子兄节点关系获取元素 逻辑性强，但是兼容性稍差 一般来说，节点至少有nodeName（节点名称）、nodeType（节点类型）、nodeValue（节点值）三个基本属性 元素节点 节点类型取值（nodeType） 元素element 1 属性attr 2 文本text 3 注释comments 8 文档document 9 注册事件概述 给元素添加事件，称为注册事件或者绑定事件 注册事件有两种方式： 传统方式 和 方法监听注册事件 传统注册方式 ： 利用on开头的事件（onclick） 特点：注册事件的唯一性，同一个元素同一个事件只能处理一个函数，最后注册的处理函数将会覆盖前面注册的处理函数 方法监听注册方式 w3c标准推荐方式 addEventListener（） IE9 之前的IE不支持此方法，可使用attachEvent（）代替 同一个元素同一个事件可以注册多个监听器，按照注册顺序执行 123btns[1].addEventListener('click', function() { alert(22); }) DOM 事件流 事件流描述的是从页面中接收事件的顺序。 事件发生时会在元素节点之间按照特定的顺序传播，这个传播过程 即 DOM事件流 分为三个阶段 捕获阶段 当前目标阶段 冒泡阶段 dom 事件流 三个阶段 ​ 1. JS 代码中只能执行捕获或者冒泡其中的一个阶段。 ​ 2. onclick 和 attachEvent（ie） 只能得到冒泡阶段。 3. 捕获阶段 如果addEventListener 第三个参数是 true 那么则处于捕获阶段 document -&gt; html -&gt; body -&gt; father -&gt; son 123456789101112131415var son = document.querySelector('.son');​ son.addEventListener('click', function() { alert('son');​ }, true);var father = document.querySelector('.father');​ father.addEventListener('click', function() {​ alert('father');​ }, true); ​ 4. 冒泡阶段 如果addEventListener 第三个参数是 false 或者 省略 那么则处于冒泡阶段 son -&gt; father -&gt;body -&gt; html -&gt; document","link":"/2022/10/07/JavaScript%E6%A0%B8%E5%BF%83DOM-2/"},{"title":"Ajax-传统请求以及缺点","text":"传统请求及缺点12345678910111213141516171819&lt;!-- 直接在浏览器地址上输入URL --&gt; &lt;!-- 超链接 --&gt; &lt;a href=&quot;old/request&quot;&gt;传统请求（超链接）&lt;/a&gt; &lt;!-- form表单提交 --&gt; &lt;form action=&quot;&quot; method=&quot;get&quot;&gt; &lt;input type=&quot;submit&quot; value=&quot;传统请求(form表单提交)&quot;&gt; &lt;/form&gt; &lt;!-- 通过JS代码来发送请求 --&gt; &lt;input type=&quot;button&quot; value=&quot;传统请求(通过JS代码发送请求)&quot; onclick=&quot;sendRequest()&quot;&gt; &lt;script type=&quot;text/javascript&quot;&gt; function sendRequest() { //发送请求 // window.location.href = ''; document.location.href = 'old/request' } &lt;/script&gt; 存在的问题 页面会全部刷新导致了用户的体验较差 传统的请求导致用户的体验有空白期（用户体验不连贯） 例如：当播放视频时，点击登录按钮 传统请求会将全部页面刷新，视频缓存重新开始，视频间断 Ajax 仅仅更新登录模块内容，不刷新整个页面","link":"/2022/10/21/Ajax-%E4%BC%A0%E7%BB%9F%E8%AF%B7%E6%B1%82%E4%BB%A5%E5%8F%8A%E7%BC%BA%E7%82%B9/"},{"title":"什么是”耦合“和”解耦“？","text":"程序员所说的“耦合”和“解耦”在工程中，对象之间的耦合度就是对象之间的依赖性。对象之间的耦合越高，维护成本越高，因此对象的设计应使类和构件之间的耦合最小。 耦合的分类 分类：有软硬件之间的耦合，还有软件各模块之间的耦合。耦合性是程序结构中各个模块之间相互关联的度量。它取决于各个模块之间的接口的复杂程度、调用模块的方式以及哪些信息通过接口。 解耦 1、解耦，字面意思就是解除耦合关系。 2、在软件工程中，降低耦合度即可以理解为解耦，模块间有依赖关系必然存在耦合，理论上的绝对零耦合是做不到的，但可以通过一些现有的方法将耦合度降至最低。 3、设计的核心思想：尽可能减少代码耦合，如果发现代码耦合，就要采取解耦技术。让数据模型，业务逻辑和视图显示三层之间彼此降低耦合，把关联依赖降到最低，而不至于牵一发而动全身。原则就是A功能的代码不要写在B的功能代码中，如果两者之间需要交互，可以通过接口，通过消息，甚至可以引入框架，但总之就是不要直接交叉写。 4、观察者模式：观察者模式存在的意义就是「解耦」，它使观察者和被观察者的逻辑不再搅在一起，而是彼此独立、互不依赖。比如网易新闻的夜间模式，当用户切换成夜间模式之后，被观察者会通知所有的观察者「设置改变了，大家快蒙上遮罩吧」。QQ消息推送来了之后，既要在通知栏上弹个推送，又要在桌面上标个小红点，也是观察者与被观察者的巧妙配合。","link":"/2022/10/22/%E4%BB%80%E4%B9%88%E6%98%AF%E2%80%9D%E8%80%A6%E5%90%88%E2%80%9C%E5%92%8C%E2%80%9D%E8%A7%A3%E8%80%A6%E2%80%9C%EF%BC%9F/"},{"title":"Ajax-XMLHttpRequest对象","text":"XMLHttpRequest对象XMLHttpRequest（XHR）对象用于与服务器交互。通过 XMLHttpRequest 可以在不刷新页面的情况下请求特定 URL，获取数据。这允许网页在不影响用户操作的情况下，更新页面的局部内容。XMLHttpRequest 在 AJAX 编程中被大量使用。 通俗来讲，AJAX利用XHR对象作为中介进行服务器与客户端的连接和数据交换。 方法 方法 描述 abort() 取消当前请求 getAllResponseHeaders() 返回头部信息 getResponseHeader() 返回特定的头部信息 open(method, url, async, user, psw) 规定请求method，请求类型GET或POSTurl，文件位置async：true(异步) 或 false(同步)， user：可选的用户名称， psw：可选的密码 send() 将请求发送到服务器， 用于GET请求 send(string) 将请求发送到服务器， 用于POST请求 setRequestHeader() 向要发送的报头添加标签/值对 1234567891011121314151617181920212223242526272829303132333435363738394041424344// abort()xhrInstance.abort();//getAllResponseHeaders()var headers = XMLHttpRequest.getAllResponseHeaders();//原始的headerdate: Fri, 08 Dec 2017 21:04:30 GMT\\r\\ncontent-encoding: gzip\\r\\nx-content-type-options: nosniff\\r\\nserver: meinheld/0.6.1\\r\\nx-frame-options: DENY\\r\\ncontent-type: text/html; charset=utf-8\\r\\nconnection: keep-alive\\r\\nstrict-transport-security: max-age=63072000\\r\\nvary: Cookie, Accept-Encoding\\r\\ncontent-length: 6502\\r\\nx-xss-protection: 1; mode=block\\r\\n//getResponseHeader()var myHeader = XMLHttpRequest.getResponseHeader(name);//open(method, url, async, user, psw)//method//要使用的 HTTP 方法，比如 GET、POST、PUT、DELETE、等。对于非 HTTP(S) URL 被忽略。//url//一个 DOMString 表示要向其发送请求的 URL。//async 可选//一个可选的布尔参数，表示是否异步执行操作，默认为 true。如果值为 false，send() 方法直到收到答复前不会返回。如果 true，已完成事务的通知可供事件监听器使用。如果 multipart 属性为 true 则这个必须为 true，否则将引发异常。xhrReq.open(method, url);xhrReq.open(method, url, async);xhrReq.open(method, url, async, user);xhrReq.open(method, url, async, user, password);//send()//send(string)//setRequestHeader() 属性 属性 描述 onreadystatechange 定义当readyState属性发生变化时被调用的函数 readyState（只读） 保存XMLHttpRequest的状态，0：请求未初始化 1： 服务器连接以及建立 2：请求已收到 3：正在处理请求 4： 请求已完成且响应已就绪 responseText（只读） 以字符串返回响应的数据 responseXML（只读） 以XML返回响应数据 status（只读） 返回请求的状态号 200 ： ”OK“ 403 ：”Forbidden“ 404 ：”Not Found statusText（只读） 返回状态文本（”OK“ ”Not Found“） //onreadystatechange XMLHttpRequest.onreadystatechange = callback; // 语法 xhr.onreadystatechange = function() { }","link":"/2022/10/22/Ajax-XMLHttpRequest%E5%AF%B9%E8%B1%A1/"},{"title":"Ajax-GET请求缓存问题","text":"GET请求缓存问题 对于低版本的IE浏览器来说，AJAX的GET请求可能会走缓存。存在缓存问题 缓存问题是什么？ 在HTTP协议中规定GET请求会被浏览器缓存起来 如果多次访问同一地址的资源，会直接从浏览器的缓存中获取（不从服务器获取），无法得到服务器新更新后的资源 GET方式请求的数据会被浏览器缓存起来，因此其他人就可以从浏览器的历史记录中读取到这些数据，例如账号和密码等。在某种情况下，GET方式会带来严重的安全问题。而POST方式相对来说就可以避免这些问题。 如何解决缓存问题？ 可以在GET请求路径url后面添加一个时间戳（随时变化），使得每次发送的请求路径都不一样。 总之就是将每次请求的url变成唯一 POST请求在HTTP协议中规定：POST请求不会被浏览器缓存 选择GET 还是 POST ？ 与 POST 相比，GET 更简单也更快，并且在大部分情况下都能用。 “GET方式提交的数据最多只能是1024字节”，因为GET是通过URL提交数据，那么GET可提交的数据量就跟URL的长度有直接关系了。而实际上，URL不存在参数上限的问题，HTTP协议规范没有对URL长度进行限制。这个限制是特定的浏览器及服务器对它的限制。IE对URL长度的限制是2083字节(2K+35)。对于其他浏览器，如Netscape、FireFox等，理论上没有长度限制，其限制取决于操作系统的支持。注意这是限制是整个URL长度，而不仅仅是你的参数值数据长度。 在以下情况中，请使用 POST 请求： 不愿使用缓存文件（更新服务器上的文件或数据库） 向服务器发送大量数据（POST 没有数据量限制） 发送包含未知字符的用户输入时，POST 比 GET 更稳定也更可靠","link":"/2022/10/22/Ajax-GET%E8%AF%B7%E6%B1%82%E7%BC%93%E5%AD%98%E9%97%AE%E9%A2%98/"},{"title":"Ajax-Axios","text":"Axios 导入axios包 1234567891011121314使用 npm:$ npm install axios使用 bower:$ bower install axios使用 yarn:$ yarn add axios使用 jsDelivr CDN:&lt;script src=&quot;https://cdn.jsdelivr.net/npm/axios/dist/axios.min.js&quot;&gt;&lt;/script&gt;使用 unpkg CDN:&lt;script src=&quot;https://unpkg.com/axios/dist/axios.min.js&quot;&gt;&lt;/script&gt; 使用axios发送GET请求 发送GET请求 12345678910&lt;script&gt; document.querySelector('#btn').addEventListener('click', function(){ var urlGet = 'http://www.liulongbin.top:3006/api/get'; var paramsObj = {name : 'zs', age : 20}; // GET 方法 axios.get(url, {params: paramsObj}).then(function(res){ console.log(res.data); // 获取传入数据 console.log(res); });&lt;/script&gt; 使用axios发送POST请求 发送POST请求 12345678910&lt;script&gt; document.querySelector('#btn').addEventListener('click', function(){ var urlPost = 'http://www.liulongbin.top:3006/api/post'; var paramsObj = {name : 'zs', age : 20}; // GET 方法 axios.get(url, paramsObj).then(function(res){ console.log(res.data); // 获取传入数据 console.log(res); });&lt;/script&gt; 使用axios直接发送请求 直接发送请求（GET） 1234567891011121314&lt;script&gt; document.querySelector('#btn').addEventListener('click', function(){ var urlGet = 'http://www.liulongbin.top:3006/api/get'; var paramsObj = {name : 'zs', age : 20}; // GET 方法 axios({ method: 'GET', url: urlGet, parames : paramsObj }).then(function(res) { console.log(res.data); // 获取传入数据 console.log(res); }) &lt;/script&gt; 直接发送请求（POST） 1234567891011121314&lt;script&gt; document.querySelector('#btn').addEventListener('click', function(){ var urlPost = 'http://www.liulongbin.top:3006/api/post'; var dataObj = {name : 'zs', age : 20}; // POST 方法 axios({ method: 'POST', url: urlGet, data : dataObj }).then(function(res) { console.log(res.data); // 获取传入数据 console.log(res); }) &lt;/script&gt;","link":"/2022/10/28/Ajax-Axios/"},{"title":"【Leedcode题目总结】-239-滑动窗口最大值","text":"给你一个整数数组 nums，有一个大小为 k 的滑动窗口从数组的最左侧移动到数组的最右侧。你只可以看到在滑动窗口内的 k 个数字。滑动窗口每次只向右移动一位。 返回 滑动窗口中的最大值 。 示例 1： 1234567891011输入：nums = [1,3,-1,-3,5,3,6,7], k = 3输出：[3,3,5,5,6,7]解释：滑动窗口的位置 最大值--------------- -----[1 3 -1] -3 5 3 6 7 3 1 [3 -1 -3] 5 3 6 7 3 1 3 [-1 -3 5] 3 6 7 5 1 3 -1 [-3 5 3] 6 7 5 1 3 -1 -3 [5 3 6] 7 6 1 3 -1 -3 5 [3 6 7] 7 12345678910111213141516171819202122var maxSlidingWindow = function(nums, k) { let res = []; let que = []; // 队列最多容纳k个数 for(let i = 0; i &lt; nums.length; i++) { if(que.length === 0) que.push(nums[i]); else { // 维护队列 // 出队列就两种情况 // 1、 队头元素不在窗口（从队头出） // 2、 当前元素大于队尾元素（从队尾出） if(i - k &gt;= 0 &amp;&amp; nums[i - k] === que[0]) que.shift(); // 当队头元素出窗口时，弹出 // 当前元素若大于队尾元素，则移出，直到遇到小于的元素或者队列空了，进队 while(que.length &gt; 0 &amp;&amp; nums[i] &gt; que[que.length - 1]){ que.pop(); } que.push(nums[i]); } // 当滑动完k个元素之后开始提取队头元素 if(i &gt;= k - 1) res.push(que[0]); } return res;};","link":"/2022/10/28/%E3%80%90Leedcode%E9%A2%98%E7%9B%AE%E6%80%BB%E7%BB%93%E3%80%91-239-%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E6%9C%80%E5%A4%A7%E5%80%BC/"},{"title":"【Leedcode题目总结】-56-合并区间","text":"以数组 intervals 表示若干个区间的集合，其中单个区间为 intervals[i] = [starti, endi] 。请你合并所有重叠的区间，并返回 一个不重叠的区间数组，该数组需恰好覆盖输入中的所有区间 。 示例 1： 123输入：intervals = [[1,3],[2,6],[8,10],[15,18]]输出：[[1,6],[8,10],[15,18]]解释：区间 [1,3] 和 [2,6] 重叠, 将它们合并为 [1,6]. 1234567891011121314151617181920212223242526272829/** * @param {number[][]} intervals * @return {number[][]} */var merge = function(intervals) { if(intervals.length === 1) return intervals; //按照第一个数字大小进行排序 intervals.sort(function(arr1, arr2) { return arr1[0] - arr2[0]; }); var resArr = []; // 保留答案 var curArr = intervals[0]; // 指向当前需要比较的区间 intervals.push(0); for(let i = 0; i &lt; intervals.length ; i++) { // 如果当前区间末尾 大于 下一区间的开头 进行合并 // 循环至不满足条件 while(intervals[i] !== 0 &amp;&amp; curArr[1] &gt;= intervals[i][0]) { var temp = [curArr[0], curArr[1] &gt; intervals[i][1] ? curArr[1] : intervals[i][1]]; curArr = temp; i++; } // 将最终循环结果存入res，如果没有经过循环，说明不需要合并，直接存入 resArr.push(curArr); // 由于循环最后会指向第一个不满足循环条件的区间，所以更新当前区间 curArr = intervals[i]; } return resArr;};","link":"/2022/10/28/%E3%80%90Leedcode%E9%A2%98%E7%9B%AE%E6%80%BB%E7%BB%93%E3%80%91-56-%E5%90%88%E5%B9%B6%E5%8C%BA%E9%97%B4/"},{"title":"Git","text":"GIT起步 关于版本控制 文件的版本 使用文件名区分版本 缺点：操作麻烦、命名不规范、容易丢失、协作困难 版本控制软件 概念：版本控制软件是一个用来记录文件变化，以便于将来查阅特定版本修订的情况，因此有时也叫做”版本控制系统“。 通俗的理解：把手工管理文件版本的方式，改为由软件管理文件的版本，负责管理文件版本的软件，叫做”版本控制软件“。 使用版本控制软件的好处 操作简便：只用识记几组简单的终端命令 便于对比：基于版本控制软件提供的功能，能够方便地比较文件的变化细节，从而查找出导致问题的原因 易于回溯：可以将选定的文件回溯到之前的状态，甚至将整个项目都会退到过去某个时间点的状态 不易丢失：再版本控制软件中，被用户误删除的文件可以轻松回复回来 协作方便：基于版本控制软件提供的分支功能，可以轻松实现多人协作开发时的代码合作操作 版本控制系统的分类 本地版本控制系统 集中化的版本控制系统 分布式的版本控制系统 分布式的版本控制系统 特点：基于服务器、客户端的运行模式 服务器保存文件的所有更新版本 客户端是服务器的完整备份，并不是只保留文件的最新版本 优点 联网运行，智齿多人协作开发 客户端断网后支持离线本地提交版本更新 服务器故障或损坏后，可使用任何一个客户端的备份进行恢复 GitGit是一个开源的分布式版本控制系统，是目前世界上最先进、最流行的版本控制系。可以快速高效地处理从很小到非常大的项目版本管理 特点：项目越大越复杂，协同开发者越多，越能体现出Git的高性能和高可用性 两个特性 直接记录快照，而非差异比较 Git快照是在原有文件版本的基础上重新生成一份新的文件，类似于备份。如果文件没有修改，Git不再重新存储该文件，二十只保留一个链接指向之前存储的文件 缺点：占用磁盘空间较大 优点：版本切换时非常快，因为每个版本都是完整的文件快照，切换版本时直接恢复目标版本的快照即可 （空间换时间） 近乎所有操作都是本地执行 断网后依旧可以在本地对项目进行版本管理 联网后，把本地修改的记录同步到云端服务器即可 SVN和Git的差异比较（集中化与分布式版本控制系统的差异） 差异 SVN Git 系统特点 1. 集中式版本控制系统，文档管理很方便。 2. 企业内部并行集中开发 3. windows系统上开发推荐使用 4. 克隆一个拥有将近一万个提交commit，五个分支，每个分支有大约1500个文件，用时将近一个小时 1. 分布式系统，代码管理很方便。 2. 开源项目开发。 3. Mac、Linux系统上开发推荐使用。 4. 克隆一个拥有将近一万个提交commit、五个分支、每个分支有大约1500个文件，用时1分钟。 灵活性 1. 搭载SVN的服务器如果出现故障，就无法与之交互。 2. 所有的SVN操作都需要中央仓库交互，例如拉分支，看日志等。 1. 可以单机操作，Git服务器故障也可以在本地Git仓库工作。 2. 除了push和pull或fetch操作，其他都可以在本地操作。 3. 根据自己开发任务任意在本地创建分支。 4. 日志都是在本地查看，效率较高。 安全性 较差，定期备份，并且是整个SVN都得备份。 较高，每个开发者的本地就是一套完整版本库，记录着版本库的所有信息。 分支方面 1. 拉分支更像是copy一个路径。 2. 可针对任何子目录进行branch。 3. 拉分支的时间较慢，因为拉分支相当于copy。 4.创建完分支后，影响全部成员，每个人都会拥有这个分支。 5.多分支并行开发较重，工作较多而且繁琐。 1. 我可以在Git的任意一个提交点commit point开启分支。 2. 拉分支时间较快，因为拉分支只是创建文件的指针和HEAD。 3. 自己本地创建的分支不会影响其他人。 4. 比较适合多分支并行开发。 5. Git checkout hash切回之前的版本，无需版本回退。 6. 强大的cherry-pick。 工作流程 1. 每次更改文件之前都得update操作，有的时候修改过程中这个文件有更新，commit不会成功。 2. 有冲突，会打断提交动作，冲突解决是一个提交速度的竞赛：手快者，先提交，平安无事；手慢者，后提交，可能遇到麻烦的冲突解决。 1. 开始工作前进行fetch操作，完成开发工作后push操作，有冲突解决冲突。 2. Git的提交过程不会被打断，有冲突会标记冲突文件。 3. Gitflow经典流程。 内容管理 SVN对中文支持好，操作简单。 对程序的源代码管理方便，代码库占用的空间少，易于分支化管理。 学习成本 使用起来更方便，SVN对中文支持好，操作简单。 更在乎效率而不是易用性，成本较高，有很多独有的命令如rebase、远程仓库交互的命令等等。 权限管理 SVN的权限管理相当严格，可以按组、个人针对某个子目录的权限控制，每个目录下都会有个.SVN的隐藏文件。 Git没有严格的权限管理控制，只有账号角色划分。 管理平台 有功能非常完善的插件。 除功能插件外，还有Gitlab、Gerrit、Github等。 Git中三个区域：工作区、暂存区、Git仓库 工作区中文件的四种状态 未被Git管理：未跟踪 已被Git管理：未修改，已修改，已暂存 Git操作的终极结果：让工作区的文件都处于’‘未修改’‘ Git中三个状态：已修改（modified）、已暂存（staged）、已提交（committed） 工作区的文件被修改了，但是还没有放到暂存区，就说已修改的状态 如果文件已修改并放入暂存区，就属于已暂存状态 如果Git仓库中保存着特定版本的文件，就属于已提交状态 基本的Git工作流程 在工作区中修改文件 将想要下次提交的更改进行暂存 提交更新，找到暂存区的文件，将快照永久存储到Git仓库 配置用户信息 ```javascript// 设置用户名和邮件地址git config –global user,name “用户名”git config –global user,email “用户邮箱”123456789101112131415161718 - 注意：如果使用了--global选项，那么该命令只需要运行一次，即可永久生效- **&lt;font color=Blue&gt;Git的全局配置文件&lt;/font&gt;** - 使用--global 命令的信息会被写入到**C:/user/用户名文件夹/.gitconfig**文件中，这个文件是Git的全局配置文件，可以使用记事本打开此文件，查看对Git做过的全局性配置- **&lt;font color=Blue&gt;检查配置信息&lt;/font&gt;** - 除了查看全局配置文件之外，还可以使用如下的终端命令，快速查看Git的全局配置信息 - ```javascript // 查看所有的全局配置项 git config --list -- global // 查看指定的全局配置项 git config user.name git config user.email 获取帮助手册 ```javascriptgit help config1234567891011121314151617- **&lt;font color=Blue&gt;获取Git仓库的两种方式&lt;/font&gt;** - 将尚未进行版本控制的**本地目录转换为Git仓库** - 1、打开”Git Bash“ - 2、执行git init 命令将当前目录转化为Git仓库 - git init 命令会创建一个名为.git的隐藏目录，这个.git目录就是当前项目的Git仓库，里面包含了初始的必要文件，这些文件是Git仓库的必要组成部分 - 从其他服务器**克隆**一个已存在的Git仓库- **&lt;font color=Blue&gt;检查文件的状态&lt;/font&gt;** - 可以使用 **git status** 命令查看文件处于什么状态- **&lt;font color=Blue&gt;检查已经加入本地Git仓库的文件&lt;/font&gt;** - ```javascript git ls-files 以精简的方式显示文件状态 git status -s git status --short 12345678910111213 - 未跟踪文件前面有红色**&lt;font color=Red&gt;？？&lt;/font&gt;**标记 - 绿色的**&lt;font color=Green&gt;A&lt;/font&gt;** 表示新添加到暂存区的文件 - 红色的**&lt;font color=Red&gt;M&lt;/font&gt;**表示修改过但**没有放入暂存区**的文件 - 绿色的**&lt;font color=Green&gt;M&lt;/font&gt;**表示暂存区中修改过的文件- **&lt;font color=Blue&gt;跟踪新文件&lt;/font&gt;** - ```javascript git add 文件名 可以开始跟踪新文件 把已跟踪的、且已修改的文件放到暂存区 把有冲突的文件标记为已解决状态 提交更新 ```javascriptgit commit -m “本次提交消息，用来对提交的内容做进一步的描述”12345678910111213- **&lt;font color=Blue&gt;对已提交的文件进行修改&lt;/font&gt;** - 当文件已被Git跟踪，并且工作区和Git仓库中的文件内容一致。此时修改文件，**再次运行 git status**命令查看状态，会出现**Changes not staged for commit** ，表示已跟踪状态的文件发生了变化，但是还没有放到暂存区，当前该文件状态为 modified- **&lt;font color=Blue&gt;暂存已修改的文件&lt;/font&gt;** - 再次运行 git add- **&lt;font color=Blue&gt;提交已暂存的文件&lt;/font&gt;** - ```javascript git commit -m &quot;修改了XX文件的内容&quot; 撤销对文件的修改 撤销对文件的修改指的是对工作区中对应文件的修改，还原成Git仓库中所保存的版本 结果：所有的修改丢失，且无法恢复 ```javascriptgit checkout –文件名 1234567 - 撤销操作的本质：用Git仓库中保存的文件，覆盖工作区中指定的文件- **&lt;font color=Blue&gt;向暂存区中一次性添加多个文件&lt;/font&gt;** - ```javascript git add . 取消暂存的文件 ```javascriptgit reset HEAD 要移除文件的名称git reset HEAD . // 移出所有文件1234567- **&lt;font color=Blue&gt;跳过使用暂存区&lt;/font&gt;** - Git的标准工作流程是**工作区-&gt;暂存区-&gt;Git仓库**，可以使用指令跳过暂存区，使其**工作区-&gt;Git仓库** - ```javascript git commit -a -m &quot;描述信息&quot; 从Git仓库移出文件 12345// 从Git仓库和工作区中同时移出文件git rm -f 文件名// 只从Git仓库中移出文件，但保留工作区中的文件git rm --cache 文件名 忽略文件 一些不希望总出现在未跟踪文件列表中的文件，可以创建一个.gitgnore的配置文件，列出要忽视的文件的匹配模式 .gitignore的格式规范如下： 以 # 开头是注释 以 / 结尾是目录 以 / 开头防止递归 以 ！开头表示取反 可以使用glob模式进行文件和文件夹的匹配（glob指简化了的正则表达式） ```javascript// 忽略所有 .a 结尾的文件*.a // 但跟踪所有的 lib.a 即使前面忽视了.a文件!lib.a //只忽略当前目录下的TODO文件，不忽略subdir/TODO/TODO //忽略任何目录下名为build的文件夹build/ // 忽略doc/notes.tet, 但不忽略doc/server/aech.txtdoc/*.txt // 忽略doc/ 目录及其所有子目录下的 .pdf文件doc/**/*.pdf 12345678910111213141516171819- **&lt;font color=Blue&gt;查看提交历史&lt;/font&gt;** - ```javascript 按时间先后顺序列出 git log 只展示最新两条提交历史 git log -2 在一行上展示最近两条提交历史的信息 git log -2 --pretty=oneline 在一行上展示最近两条提交历史，并自定义输出的格式 %h -- 提交的简写哈希值 %an -- 作者名字 %ar -- 作者修订日期 %s -- 提交说明 git log -2 --pretty=format:&quot;%h | %an | %ar | %s&quot; 跳转到指定版本 在一行上展示最近两条提交历史的信息 git log --pretty=oneline 根据ID跳转到指定版本 git reset --hard &lt;CommitID&gt; 在旧版本中使用 git relog --pretty=oneline 根据ID跳转到指定版本 git reset --hard &lt;CommitID&gt;","link":"/2022/10/30/Git/"},{"title":"webpack-如何删除项目多余文件","text":"删除项目多余文件项目迭代会产生多余的功能或者弃用的功能，针对此类功能，大多数是将入口关闭，或者注释掉部分代码，但是依赖的文件（js/css/png/jpg等）并没有删除掉。 删除项目多余文件的操作有： 使用useless-files-webpack-plugin插件 安装 1npm i useless-files-webpack-plugin -D 在 webpack.config.js中添加 1const UselessFile = require('useless-files-webpack-plugin'); 在plugins 中添加插件配置 12345678new UselessFile({ root: './src', // 项目目录 out: './fileList.json', // 输出文件列表 // out: (files) =&gt; deal(files), // 或者回调处理 clean: false // 删除文件, exclude: path // 排除文件列表, 格式为文件路径数组}), 使用webpack打包时，会在根目录下生成 unused-files.json文件，保存着无用文件列表 根据列表中的提供路径，核对相应文件是否需要保留。无需保留，手动删除即可。","link":"/2022/11/12/webpack-%E5%A6%82%E4%BD%95%E5%88%A0%E9%99%A4%E9%A1%B9%E7%9B%AE%E5%A4%9A%E4%BD%99%E6%96%87%E4%BB%B6/"},{"title":"XSS攻击","text":"什么是XSS攻击？ 跨站脚本（Cross-site scripting，简称为：CSS, 但这会与层叠样式表（Cascading Style Sheets，CSS）的缩写混淆。因此，跨站脚本攻击缩写为XSS）是一种网站应用程序的安全漏洞攻击。 XSS攻击通常指的是通过利用网页开发时留下的漏洞，通过巧妙的方法注入恶意指令代码到网页，使用户加载并执行攻击者恶意制造的网页程序。这些恶意网页程序通常是JavaScript，但实际上也可以包括Java、 VBScript、 LiveScript、ActiveX、 Flash 或者甚至是普通的HTML。攻击成功后，攻击者可能得到包括但不限于更高的权限（如执行一些操作）、私密网页内容、会话和cookie等各种内容。 XSS攻击类型 最常见的几种分类：反射型（非持久型）XSS、存储型（持久型）XSS、DOM型XSS、通用型XSS、突变型XSS。 反射型攻击 将恶意链接传入发送给用户，诱导用户点击恶意链接，访问目标服务器，在得到目标服务器返回的数据之后，用户会解析数据（含有恶意URL），访问攻击者事先设置好的恶意服务器，使得攻击者得到用户数据 主要场景有以下几种： 将不可信数据插入到HTML标签之间时；// 例如div, p, td； 将不可信数据插入到HTML属性里时；// 例如：&lt;div width=$INPUT&gt;&lt;/div&gt; 将不可信数据插入到SCRIPT里时；// 例如：&lt;script&gt;var message = ” $INPUT “;&lt;/script&gt; 还有插入到Style属性里的情况，同样具有一定的危害性；// 例如&lt;span style=” property : $INPUT ”&gt;&lt;/span&gt; 将不可信数据插入到HTML URL里时，// 例如：&lt;a href=”[http://www.abcd.com?param=](http://www.ccc.com/?param=) $INPUT ”&gt;&lt;/a&gt; 使用富文本时，没有使用XSS规则引擎进行编码过滤。 存储型攻击（ HTML 注入型/持久型） 直接将恶意脚本输入到服务器中保存下来，使得其它用户（前端）和管理员（前后端）在访问资源时执行了恶意代码，用户访问服务器-跨站链接-返回跨站代码。 DOM型XSS 通用型XSS 预防XSS攻击XSS 攻击有两大要素： 1. 攻击者提交恶意代码。 2. 浏览器执行恶意代码。 1.预防 DOM 型 XSS 攻击DOM 型 XSS 攻击，实际上就是网站前端 JavaScript 代码本身不够严谨，把不可信的数据当作代码执行了。 在使用 .innerHTML、.outerHTML、document.write() 时要特别小心，不要把不可信的数据作为 HTML 插到页面上，而应尽量使用 .textContent、.setAttribute() 等。 DOM 中的内联事件监听器，如 location、onclick、onerror、onload、onmouseover 等， 标签的href属性，JavaScript 的eval()、setTimeout()、setInterval()等，都能把字符串作为代码运行。如果不可信的数据拼接到字符串中传递给这些 API，很容易 产生安全隐患，请务必避免。 2.输入过滤如果由前端过滤输入，然后提交到后端的话。一旦攻击者绕过前端过滤，直接构造请求，就可以提交恶意代码了。 那么，换一个过滤时机：后端在写入数据库前，对输入进行过滤，然后把“安全的”内容，返回给前端。这样是否可行呢？ 我们举一个例子，一个正常的用户输入了 5 &lt; 7 这个内容，在写入数据库前，被转义，变成了 5 $lt; 7。 问题是：在提交阶段，我们并不确定内容要输出到哪里。 这里的“并不确定内容要输出到哪里”有两层含义： 用户的输入内容可能同时提供给前端和客户端，而一旦经过了 escapeHTML()，客户端显示的内容就变成了乱码( 5 $lt;7 )。 在前端中，不同的位置所需的编码也不同。 当 5 $lt;7 作为 HTML 拼接页面时，可以正常显示：5 &lt; 7 所以输入过滤非完全可靠，我们就要通过“防止浏览器执行恶意代码”来防范 XSS，可采用下面的两种方法 3.前端渲染把代码和数据分隔开在前端渲染中，我们会明确的告诉浏览器：下面要设置的内容是文本（.innerText），还是属性（.setAttribute），还是样式 （.style）等等。浏览器不会被轻易的被欺骗，执行预期外的代码了。 Javascript：可以使用textContent或者innerText的地方，尽量不使用innerHTML； query：可以使用text()得地方，尽量不使用html()； 4.拼接HTML时对其进行转义如果拼接 HTML 是必要的，就需要采用合适的转义库，对 HTML 模板各处插入点进行充分的转义。 常用的模板引擎，如 doT.js、ejs、FreeMarker 等，对于 HTML 转义通常只有一个规则，就是把 &amp; &lt; &gt; “ ‘ / 这几个字符转义掉，确 实能起到一定的 XSS 防护作用，但并不完善： 这里推荐一个前端防止XSS攻击的插件: js-xss的使用和源码解读，Git 3.8K 的Star和60W的周下载量证明了其强大性.","link":"/2022/11/15/XSS%E6%94%BB%E5%87%BB/"},{"title":"Vue-前期准备","text":"实际的开发 模块化（JS 的模块化，css的模块化， 资源的模块化） 组件化（复用现有的UI结构、样式、行为） 规范化（目录结构的划分、编码规范化、接口规范化、文档规范化、Git分支管理） 自动化（自动化构建、自动部署、自动化测试） Webpack 概念：webpack是前端工程化的具体解决方案 webpack 是一个用于现代 JavaScript 应用程序的 静态模块打包工具。当 webpack 处理应用程序时，它会在内部从一个或多个入口点构建一个 依赖图(dependency graph)，然后将你项目中所需的每一个模块组合成一个或多个 bundles，它们均为静态资源，用于展示你的内容。 主要功能：它提供了友好的前端模块化开发支持，以及代码压缩混淆，处理浏览器端JS的兼容性，性能优化等强大的功能 webpack基础 在项目中安装webpack npm install webpack@5.42.1 webpack-cli@4.7.2 –save-dev -S 是 –save 的简写 （如果某个包在开发和部署之后都需要用到，则需要使用该命令安装到”dependencies”） -D 是 –save-dev的jianxie （如果某个包只在开发过程中用到，则使用该命令安装到”devDependencies”） 配置webpack 1、在项目根目录中，创建名为 webpack.config.js 的webpack配置文件，并初始化如下的基本配置: 12345module.exports = { mode: 'development' // mode 用来指定构建模式， 可选值有 development 和 production}// development ： 追求打包速度，不是体积// production，体积小，打包速度慢 不写mode默认为production 2、在 package.json 的 script 节点下，新增dev脚本如下： 123&quot;scripts&quot;: { &quot;dev&quot;: &quot;webpack&quot; // script 节点下的脚本，可以通过npm run执行，例如 npm run dev} 3、 在终端中运行 npm run dev命令，启动webpack 进行项目的打包构建","link":"/2022/11/15/Vue-%E5%89%8D%E6%9C%9F%E5%87%86%E5%A4%87/"},{"title":"Vue-使用","text":"Vue的使用 基本步骤 导入vue.js的script脚本文件 在页面中声明一个将要被Vue所控制的DOM区域 创建vm实例对象（vue实例对象） 123456789101112131415161718192021222324252627282930&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;!-- vue控制的div --&gt; &lt;div id=&quot;app&quot;&gt;{{ username }}&lt;/div&gt; &lt;!-- 导入vue文件 --&gt; &lt;script src=&quot;./lib/vue-2.6.12.js&quot;&gt; &lt;/script&gt; &lt;!-- 创建vue的实例对象 --&gt; &lt;script&gt; const vm = new Vue({ el: '#app', data: { username : 'zs' } }) &lt;/script&gt;&lt;/body&gt;&lt;/html&gt;","link":"/2022/11/15/Vue-%E4%BD%BF%E7%94%A8/"},{"title":"Vue-特性","text":"Vue 的特性 数据驱动视图 当页面数据发生变化时，页面会自动重新渲染 数据驱动试图时单项的数据绑定 获取到数据之后，Vue可以监听到数据的变化，然后渲染页面（不需要频繁操作DOM） 双向数据绑定 在网页中，form表单负责采集数据，Ajax负责提交数据 在填写表单时，双向绑定可以辅助开发者在不操作DOM的前提下，自动把用户填写的内容同步到数据源中 js 数据的变化，会被自动渲染到页面上 页面上表单采集的数据发生变化的时候，会被vue自动获取并更新到js数据中 MVVM MVVM 是vue实现 数据驱动视图 和 双向数据绑定 的核心原理。 MVVM指的是Model、View和ViewModel，他把每个HTML页面都拆分成了三个部分 Model：表示当前页面渲染时所依赖的数据源 View：表示当前页面所渲染的DOM结构 ViewModel：表示vue的实例（包含DOM listeners 和 Data Bindings） 当数据源发生变化时，会被ViewModel监听到，VM会根据最新的数据源自动更新页面的结构 当表单元素的值发生变化时，也会被VM监听到，VM会把变化过后最新的值自动同步到Model数据源中","link":"/2022/11/15/Vue-%E7%89%B9%E6%80%A7/"},{"title":"HTML-Form表单详解","text":"Form表单详解 在HTML中，form标签称为表单 表单在页面样式中不会产生任何影响，但是会影响页面的行为 可以将表单中的数据，使用指定的请求方式（get 或 post），提交到指定的服务器地址 主要有以下四个内容 请求时机 请求方式 请求地址 发送的数据 请求时机有两种情况都会导致form表单的提交 点击了表单中的提交按钮 提交按钮指的是，type=&quot;submit&quot;的按钮（不管是button还是input）。另外，type=&quot;image&quot;的input标签，也可以实现提交，也可以当做是提交按钮。 注意点： 提交按钮必须放置在表单里面 点击提交按钮时，只提交它所在的表单 在 JS 中调用的表单对象的submit方法 1、获取form表单的dom对象 2、为dom对象绑定事件 3、提交form表单 请求方式了解了form表单的提交时机，再来看它的请求方式 所谓请求方式，就是提交时将使用什么类型的请求（get、post）发送给服务器 使用form标签的method属性，可以控制form表单的提交方式，该属性可以省略，若省略，默认的提交方式是get 当使用get方式提交表单时，浏览器会将表单中的数据添加到地址后面，作为地址参数 下面的form表单使用了get的方式提交请求： 1234&lt;form action=&quot;/server.php&quot; method=&quot;get&quot;&gt; &lt;p&gt;账号：&lt;input type=&quot;text&quot; name=&quot;loginid&quot;&gt;&lt;/p&gt; &lt;p&gt;密码：&lt;input type=&quot;password&quot; name=&quot;loginpwd&quot;&gt;&lt;/p&gt; &lt;p&gt;&lt;button type=&quot;submit&quot;&gt;提交&lt;/button&gt;&lt;/p&gt;&lt;/form&gt; 当提交表单时，向服务器发送以下信息： 请求地址：/server.php?loginid=账号文本框内容&amp;loginpwd=密码文本框内容 请求体：无 反之，如果使用post的方式提交请求： 1234&lt;form action=&quot;/server.php&quot; method=&quot;post&quot;&gt; &lt;p&gt;账号：&lt;input type=&quot;text&quot; name=&quot;loginid&quot;&gt;&lt;/p&gt; &lt;p&gt;密码：&lt;input type=&quot;password&quot; name=&quot;loginpwd&quot;&gt;&lt;/p&gt; &lt;p&gt;&lt;button type=&quot;submit&quot;&gt;提交&lt;/button&gt;&lt;/p&gt;&lt;/form&gt; 当提交表单时，则向服务器发送以下信息： 请求地址：/server.php 请求体：loginid=账号文本框内容&amp;loginpwd=密码文本框内容 请求地址表单中的请求地址是指，当提交form表单时，会将表单中的数据提交到服务的哪个地址去处理，就好比你去政府办事，你要把你的资料提交给哪个部门来处理 你可以使用form标签的action属性来设置其提交地址，该属性如果被省略，则默认为当前页面地址 12345&lt;!-- 当提交表单时，会将表单内容发送给/server.php这个地址处理 --&gt;&lt;form action=&quot;/server.php&quot; method=&quot;post&quot;&gt; &lt;p&gt;账号：&lt;input type=&quot;text&quot; name=&quot;loginid&quot;&gt;&lt;/p&gt; &lt;p&gt;密码：&lt;input type=&quot;password&quot; name=&quot;loginpwd&quot;&gt;&lt;/p&gt; &lt;p&gt;&lt;button type=&quot;submit&quot;&gt;提交&lt;/button&gt;&lt;/p&gt;&lt;/form&gt; 发送的数据可以被表单发送的数据必须满足： 具有name属性的标签 必须是**包含在form标签里的 ** input、select、textarea标签，其他标签不会提交到服务器 提交数据时，键值对分别如下： 键：标签的name属性值 值：标签的value属性值","link":"/2022/11/16/HTML-Form%E8%A1%A8%E5%8D%95%E8%AF%A6%E8%A7%A3/"},{"title":"Vue-指令与过滤器","text":"- 指令与过滤器指令 指令：是vue为开发者提供的模板语法，用于辅助开发者渲染页面的基本结构 vue中的指令按照用途可以分为6大类： 内容渲染指令 内容渲染指令用来辅助开发者渲染DOM元素的文本内容，常用的内容渲染指令有如下3个： v-text &lt;p v-text = &quot;username&quot;&gt;&lt;/p&gt; 12345678910 - **缺点：** - **会覆盖标签内部原本的内容** - **不能渲染html标签**- {{}} 插值表达式（Mustache） - ```html &lt;div id=&quot;app&quot;&gt;{{ username }}&lt;/div&gt; 缺点:不能渲染html标签 插入的值发生变化,内容会跟着变化 使用v-once指令可以一次性的插值, 当数据改变时, 插值处的内容不会更新. &lt;span v-once&gt;这个将不会改变: {{ msg }}&lt;/span&gt; 12345- v-html - ```html &lt;p v-html = &quot;info&quot;&gt;&lt;/p&gt; 可以渲染带有标签的字符串成HTML内容 属性绑定指令 注意: 插值表达式只能用在 内容渲染指令 v-bind 可以使用v-bind指令(缩写 : )对DOM节点中的属性进行动态绑定 ```html 1234567891011121314151617181920212223242526272829303132333435- **事件绑定指令** - `v-on` - 利用v-on指令对DOM节点进行事件绑定 - ```html &lt;div id=&quot;app&quot;&gt; &lt;p&gt;count 的值是 {{count}}&lt;/p&gt; &lt;button @click=&quot;addCount(99)&quot;&gt;+1&lt;/button&gt; &lt;button v-on:click=&quot;subCount&quot;&gt;-1&lt;/button&gt; &lt;/div&gt; &lt;!-- 导入vue文件 --&gt; &lt;script src=&quot;./lib/vue-2.6.12.js&quot;&gt; &lt;/script&gt; &lt;!-- 创建vue的实例对象 --&gt; &lt;script&gt; const vm = new Vue({ el: '#app', data: { count: 3, }, methods: { addCount (n) { vm.count += n }, subCount() { vm.count-- } } }) &lt;/script&gt; 在vm实例中添加methods属性，定义事件 缩写@+绑定事件类型 $event 表示原本的事件对象e , 如需使用，可以作为参数传递进事件函数 事件修饰符 加在事件绑定的后面控制事件触发 @click.prevent 阻止默认行为（链接跳转，表单提交等） @click.stop 阻止事件冒泡 @click.capture @click.once @click.self 按键修饰符 在监听键盘事件时，可以为键盘相关事件添加按键修饰符（@keyup.enter , @keyup.esc） 双向绑定指令 v-model 用来辅助开发者在不操作DOM的前提下，快速获取表单内容 可以双向绑定数据（用户的输入改变，可以同时改变data中的数据，反之也是），v-bind只能实现单向绑定 配套的HTML标签 input输入框 textarea select 专用修饰符 .number : 将采集到的数据转为number ，如果不转换，默认为string .trim ： 自动过滤用户输入的首位空白字符 .lazy：在 “change” 时而非 “input” 时更新，防抖，用户输入的时候不改变data中的数据，只在用户输入完成（失去焦点时）进行更改 条件渲染指令 用来辅助开发者按需控制DOM的显示与隐藏 v-if 隐藏方式：动态删除或创建元素 v-else if , v-else v-show 隐藏方式：修改标签的行内样式 display: none 频繁切换元素的显示状态，使用v-show性能更好 刚生成页面时，某些元素不需要展示，则使用v-if更好 列表渲染指令 v-for 基于一个数组来玄幻渲染一个列表结构，需要使用item in items形式，其中 items是待循环的数组，item是被循环的每一项 ```html 索引 ID 姓名 &lt;/table&gt; &lt;/ul&gt; &lt;script&gt; const vm = new Vue({ el: '#app', data: { list : [ {id: 1, name: 'www'}, {id: 2, name: 'hhh'}, {id: 3, name: 'ddd'}, ] } }) &lt;/script&gt; 123456789101112131415161718 - v-for 还支持可选的第二个参数，当前项的索引，语法格式为`(item, index) in items` - **需要注意的点** - 只要用到了v-for指令，那么一定要绑定一个 :key 属性，而且尽量把id作为key的值 - key只能是字符串或数字类型 - key不允许重复（必须具有唯一性） - 使用index的值作为key的值没用任何意义### 过滤器&gt;过滤器是vue为开发者提供的功能，常用于文本的格式化。过滤器可以用在两个地方：插值表达式和v-bind属性绑定&gt;&gt;过滤器应该被添加在JavaScript表达式的尾部，由”管道符“进行调用```html{{message | capitaliza}} 注意点 要定义在filters节点下，本质是一个函数 在过滤器函数中，一定要由返回值 message 是capitaliza 过滤函数 的参数 私有过滤器 在filters节点下定义的过滤器，称为”私有过滤器“，只能在当前vm实例所使用 全局过滤器123vue.filter('capitalize', (str) =&gt; { }) 第一个参数，是全局过滤器的名字 第二个参数，是全局过滤器的处理函数 如果全局过滤器和私有过滤器名字一致，此时按照就近原则，调用私有过滤器 可以连续调用多个过滤器 1{{ message | xxx | YYY }} 过滤器的本质是 JS函数，可以接收参数，只能从第二个参数开始接收 12345{{ message | filter(arg1, arg2) }}Vue.filter('filter', (message, arg1, arg2) =&gt; {})","link":"/2022/11/16/Vue-%E6%8C%87%E4%BB%A4%E4%B8%8E%E8%BF%87%E6%BB%A4%E5%99%A8/"}],"tags":[{"name":"JS","slug":"JS","link":"/tags/JS/"},{"name":"Leedcode","slug":"Leedcode","link":"/tags/Leedcode/"},{"name":"计算机知识杂烩","slug":"计算机知识杂烩","link":"/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%9F%A5%E8%AF%86%E6%9D%82%E7%83%A9/"},{"name":"Ajax","slug":"Ajax","link":"/tags/Ajax/"},{"name":"CSS","slug":"CSS","link":"/tags/CSS/"},{"name":"JS-DOM","slug":"JS-DOM","link":"/tags/JS-DOM/"},{"name":"Git","slug":"Git","link":"/tags/Git/"},{"name":"webpack","slug":"webpack","link":"/tags/webpack/"},{"name":"Vue","slug":"Vue","link":"/tags/Vue/"},{"name":"HTML","slug":"HTML","link":"/tags/HTML/"}],"categories":[]}