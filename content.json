{"pages":[],"posts":[{"title":"CSS tips","text":"精灵图精灵图使用步骤： ​ 1 创建一个盒子，设置盒子的尺寸和小图尺寸相同 ​ 2 将精灵图设置为盒子的背景图片 ​ 3 修改背景图位置 ​ 通过pxcood 测量小图片左上角坐标， 分别取负值设置给盒子的 background-position : x y 过渡 作用：让元素的样式慢慢的变化，常配合hover使用，增强网页交互体验 属性名： transition 常见取值： ​ 过渡的属性 – all（所有能过渡的属性都过渡、具体属性名如：width：只有width有过度） ​ 过渡的时长 – 数字+s 注意点： ​ 过渡需要：默认状态和hover状态样式不同，才能有过渡效果 ​ transition属性给需要过渡的元素本身加 ​ transition属性设置在不同状态中，效果不同 ​ 1 给默认状态设置，鼠标移入移出都有过渡效果 ​ 2 给hover状态设置，鼠标移入有过渡效果，移出没有过渡效果 文件和目录准备 新建项目文件夹 项目名(英文)-pc-client，在VScode中打开 在实际开发中，项目文件夹不建议使用中文 所有项目相关文件都保存在项目名(英文)-pc-client目录中 复制favicon.ico (网页标题图标)到项目名(英文)-pc-client目录 一般习惯将ico图标放在项目根目录 复制 image 和 uploads目录到项目名(英文)-pc-client目录中 image：存放网站固定使用的图片素材，如：logo、样式修饰图片等等 uploads： 存放网站非固定使用的图片素材，如：商品图片、宣传图片等 新建 index.html 在根目录 新建css文件夹保存网站的样式，并新建以下css文件： base.css: 基础公共样式 common.css: 该网站中多个网页相同模块的重复样式，如：头部、底部 index.css：首页样式","link":"/2022/09/21/CSS-tips/"},{"title":"Hello World","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new &quot;My New Post&quot; More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","link":"/2022/09/21/hello-world/"},{"title":"发博操作","text":"将博客部署到GitHub上： 1234hexo cleanhexo generate(若要本地预览就先执行 hexo server)hexo deploy 快捷命令： 1234hexo g == hexo generatehexo d == hexo deployhexo s == hexo serverhexo n == hexo new 还能组合使用，如： 1hexo d -g 创建新文本文档 1hexo new &quot;文件名称&quot;","link":"/2022/09/21/%E5%8F%91%E5%8D%9A%E6%93%8D%E4%BD%9C/"},{"title":"JS-数据类型","text":"数据类型 基本（值）类型 String : 任意字符串 Number ： 任意的数字 Boolean ： true false undefined ： 未定义的值。表示一个变量最原始的状态，而非人为操作的结果。 这种原始状态会在以下 4 种场景中出现： 1、声明一个变量，但是没有赋值123var foo;console.log(foo); // undefined复制代码 访问 foo，返回了 undefined，表示这个变量自从声明了以后，就从来没有使用过，也没有定义过任何有效的值。 2、访问对象上不存在的属性或者未定义的变量123console.log(Object.foo); // undefinedconsole.log(typeof demo); // undefined复制代码 访问 Object 对象上的 foo 属性，返回 undefined ， 表示Object 上不存在或者没有定义名为 foo 的属性；对未声明的变量执行typeof操作符返回了undefined值。 3、函数定义了形参，但没有传递实参123456//函数定义了形参 afunction fn(a) { console.log(a); // undefined}fn(); //未传递实参复制代码 函数 fn 定义了形参 a，但 fn 被调用时没有传递参数，因此，fn 运行时的参数 a 就是一个原始的、未被赋值的变量。 4、使用void对表达式求值123456void 0 ; // undefinedvoid false; // undefinedvoid []; // undefinedvoid null; // undefinedvoid function fn(){} ; // undefined复制代码 ECMAScript 明确规定 void 操作符 对任何表达式求值都返回 undefined ，这和函数执行操作后没有返回值的作用是一样的，JavaScript 中的函数都有返回值，当没有 return 操作时，就默认返回一个原始的状态值，这个值就是 undefined，表明函数的返回值未被定义。 因此，undefined 一般都来自于某个表达式最原始的状态值，不是人为操作的结果。当然，你也可以手动给一个变量赋值 undefined，但这样做没有意义，因为一个变量不赋值就是 undefined 。 null ： 空值，表示一个对象被人为的重置为空对象，而非一个变量最原始的状态。在内存里的表示就是，栈中的变量没指向堆中的内存对象。 1、一般在以下两种情况下我们会将变量赋值为null 如果定义的变量在将来用于保存对象，那么最好将该变量初始化为null，而不是其他值。换句话说，只要意在保存对象的变量还没有真正保存对象，就应该明确地让该变量保存null值，这样有助于进一步区分null和undefined。 当一个数据不再需要使用时，我们最好通过将其值设置为null来释放其引用，这个做法叫做解除引用。不过解除一个值的引用并不意味着自动回收改值所占用的内存。解除引用的真正作用是让值脱离执行环境，以便垃圾收集器在下次运行时将其回收。解除引用还有助于消除有可能出现的循环引用的情况。这一做法适用于大多数全局变量和全局对象的属性，局部变量会在它们离开执行环境时(函数执行完时)自动被解除引用。 2、特殊的typeof null当我们使用typeof操作符检测null值，我们理所应当地认为应该返”Null”类型呀，但是事实返回的类型却是”object”。 123var data = null;console.log(typeof data); // &quot;object&quot;复制代码 是不是很奇怪？其实我们可以从两方面来理解这个结果: 一方面从逻辑角度来看，null值表示一个空对象指针，它代表的其实就是一个空对象，所以使用typeof操作符检测时返回”object”也是可以理解的。 另一方面，其实在JavaScript 最初的实现中，JavaScript 中的值是由一个表示类型的标签和实际数据值表示的(对象的类型标签是 0)。由于 null 代表的是空指针（大多数平台下值为 0x00），因此，null的类型标签也成为了 0，typeof null就错误的返回了”object”。在ES6中，当时曾经有提案为历史平凡, 将type null的值纠正为null, 但最后提案被拒了,所以还是保持”object”类型。 对象（引用）类型 Object ： 任意对象 Function ： 函数（一种特别的对象） Array ： 数组 (内部数据是有序的) 判断 typeof 可以判断 ： undefined | 数值 | 字符串 | 布尔值 | function 不能判断： null 和 object | array 和 object instanceof : 判断对象的具体类型 === 可以判断undefined, null","link":"/2022/09/23/JS-%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/"}],"tags":[{"name":"JS","slug":"JS","link":"/tags/JS/"}],"categories":[]}