{"pages":[],"posts":[{"title":"CSS tips","text":"精灵图精灵图使用步骤： ​ 1 创建一个盒子，设置盒子的尺寸和小图尺寸相同 ​ 2 将精灵图设置为盒子的背景图片 ​ 3 修改背景图位置 ​ 通过pxcood 测量小图片左上角坐标， 分别取负值设置给盒子的 background-position : x y 过渡 作用：让元素的样式慢慢的变化，常配合hover使用，增强网页交互体验 属性名： transition 常见取值： ​ 过渡的属性 – all（所有能过渡的属性都过渡、具体属性名如：width：只有width有过度） ​ 过渡的时长 – 数字+s 注意点： ​ 过渡需要：默认状态和hover状态样式不同，才能有过渡效果 ​ transition属性给需要过渡的元素本身加 ​ transition属性设置在不同状态中，效果不同 ​ 1 给默认状态设置，鼠标移入移出都有过渡效果 ​ 2 给hover状态设置，鼠标移入有过渡效果，移出没有过渡效果 文件和目录准备 新建项目文件夹 项目名(英文)-pc-client，在VScode中打开 在实际开发中，项目文件夹不建议使用中文 所有项目相关文件都保存在项目名(英文)-pc-client目录中 复制favicon.ico (网页标题图标)到项目名(英文)-pc-client目录 一般习惯将ico图标放在项目根目录 复制 image 和 uploads目录到项目名(英文)-pc-client目录中 image：存放网站固定使用的图片素材，如：logo、样式修饰图片等等 uploads： 存放网站非固定使用的图片素材，如：商品图片、宣传图片等 新建 index.html 在根目录 新建css文件夹保存网站的样式，并新建以下css文件： base.css: 基础公共样式 common.css: 该网站中多个网页相同模块的重复样式，如：头部、底部 index.css：首页样式","link":"/2022/09/21/CSS-tips/"},{"title":"Hello World","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new &quot;My New Post&quot; More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","link":"/2022/09/21/hello-world/"},{"title":"发博操作","text":"将博客部署到GitHub上： 1234hexo cleanhexo generate(若要本地预览就先执行 hexo server)hexo deploy 快捷命令： 1234hexo g == hexo generatehexo d == hexo deployhexo s == hexo serverhexo n == hexo new 还能组合使用，如： 1hexo d -g 创建新文本文档 1hexo new &quot;文件名称&quot;","link":"/2022/09/21/%E5%8F%91%E5%8D%9A%E6%93%8D%E4%BD%9C/"},{"title":"JS-数据类型","text":"数据类型 基本（值）类型 String : 任意字符串 Number ： 任意的数字 Boolean ： true false undefined ： 未定义的值。表示一个变量最原始的状态，而非人为操作的结果。 这种原始状态会在以下 4 种场景中出现： 1、声明一个变量，但是没有赋值123var foo;console.log(foo); // undefined复制代码 访问 foo，返回了 undefined，表示这个变量自从声明了以后，就从来没有使用过，也没有定义过任何有效的值。 2、访问对象上不存在的属性或者未定义的变量123console.log(Object.foo); // undefinedconsole.log(typeof demo); // undefined复制代码 访问 Object 对象上的 foo 属性，返回 undefined ， 表示Object 上不存在或者没有定义名为 foo 的属性；对未声明的变量执行typeof操作符返回了undefined值。 3、函数定义了形参，但没有传递实参123456//函数定义了形参 afunction fn(a) { console.log(a); // undefined}fn(); //未传递实参复制代码 函数 fn 定义了形参 a，但 fn 被调用时没有传递参数，因此，fn 运行时的参数 a 就是一个原始的、未被赋值的变量。 4、使用void对表达式求值123456void 0 ; // undefinedvoid false; // undefinedvoid []; // undefinedvoid null; // undefinedvoid function fn(){} ; // undefined复制代码 ECMAScript 明确规定 void 操作符 对任何表达式求值都返回 undefined ，这和函数执行操作后没有返回值的作用是一样的，JavaScript 中的函数都有返回值，当没有 return 操作时，就默认返回一个原始的状态值，这个值就是 undefined，表明函数的返回值未被定义。 因此，undefined 一般都来自于某个表达式最原始的状态值，不是人为操作的结果。当然，你也可以手动给一个变量赋值 undefined，但这样做没有意义，因为一个变量不赋值就是 undefined 。 null ： 空值，表示一个对象被人为的重置为空对象，而非一个变量最原始的状态。在内存里的表示就是，栈中的变量没指向堆中的内存对象。 1、一般在以下两种情况下我们会将变量赋值为null 如果定义的变量在将来用于保存对象，那么最好将该变量初始化为null，而不是其他值。换句话说，只要意在保存对象的变量还没有真正保存对象，就应该明确地让该变量保存null值，这样有助于进一步区分null和undefined。 当一个数据不再需要使用时，我们最好通过将其值设置为null来释放其引用，这个做法叫做解除引用。不过解除一个值的引用并不意味着自动回收改值所占用的内存。解除引用的真正作用是让值脱离执行环境，以便垃圾收集器在下次运行时将其回收。解除引用还有助于消除有可能出现的循环引用的情况。这一做法适用于大多数全局变量和全局对象的属性，局部变量会在它们离开执行环境时(函数执行完时)自动被解除引用。 2、特殊的typeof null当我们使用typeof操作符检测null值，我们理所应当地认为应该返”Null”类型呀，但是事实返回的类型却是”object”。 123var data = null;console.log(typeof data); // &quot;object&quot;复制代码 是不是很奇怪？其实我们可以从两方面来理解这个结果: 一方面从逻辑角度来看，null值表示一个空对象指针，它代表的其实就是一个空对象，所以使用typeof操作符检测时返回”object”也是可以理解的。 另一方面，其实在JavaScript 最初的实现中，JavaScript 中的值是由一个表示类型的标签和实际数据值表示的(对象的类型标签是 0)。由于 null 代表的是空指针（大多数平台下值为 0x00），因此，null的类型标签也成为了 0，typeof null就错误的返回了”object”。在ES6中，当时曾经有提案为历史平凡, 将type null的值纠正为null, 但最后提案被拒了,所以还是保持”object”类型。 对象（引用）类型 Object ： 任意对象 Function ： 函数（一种特别的对象） Array ： 数组 (内部数据是有序的) 判断 typeof 可以判断 ： undefined | 数值 | 字符串 | 布尔值 | function 不能判断： null 和 object | array 和 object instanceof : 判断对象的具体类型 === 可以判断undefined, null","link":"/2022/09/23/JS-%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/"},{"title":"JavaScript核心Web APIs[1]","text":"Web APIs Web APIs是W3C组织的标准 Web APIs 主要学习DOM 和 BOM Web APIs 是JS所独有的部分 主要学习页面交互功能 需要JS基础 APIAPI 是一些预先定义的函数，目的是提供应用程序与开发人员基于某软件或硬件得以访问一组例程的能力，而又无需访问源码。 Web APIweb API 是浏览器提供的一套操作浏览器功能和页面元素的API（BOM 和 DOM）。 DOM文档对象模型 （Document Object Model， 简称DOM）， 是W3C组织推荐的处理可扩展标记语言（HTML 或者 XML） 的标准编程接口。 DOM树 文档：一个页面一个文档，DOM使用document表示 元素：页面中的所有标签都是元素，DOM中使用element表示 节点： 网页中所有内容都是节点（标签、属性、文本、注释等），DOM中使用node表示 以上内容都看作对象 获取元素 根据ID获取 使用 getElementById() 方法获取 Document的方法 getElementById()返回一个匹配特定 ID的元素。由于元素的 ID 在大部分情况下要求是独一无二的，这个方法自然而然地成为了一个高效查找特定元素的方法。 如果需要查找到那些没有 ID 的元素，你可以考虑通过 CSS 选择器使用 querySelector()。 语法 1var element = document.getElementById(id); Copy to Clipboard 参数 **element**是一个 Element 对象。如果当前文档中拥有特定 ID 的元素不存在则返回 null. **id**是大小写敏感的字符串，代表了所要查找的元素的唯一 ID. 返回值 返回一个匹配到 ID 的 DOM Element 对象。若在当前 Document 下没有找到，则返回 null。 根据标签名获取 使用getElementsTagName()方法返回带有指定标签名的对象的集合（以伪数组的形式存储）。 获取某个元素（父元素）内部所有指定标签名的子元素 1element.getElementsByTagName('标签名') 注意：父元素必须是单个对象（必须指明是哪一个元素对象）。获取的时候不包括父元素自己 通过HTML5新增的方法获取 document.getElementsByClassName('类名');// 根据类名返回元素对象集合 1234567- ```javascript document.querySelector(&quot;.类名&quot;); // 返回指定选择器的第一个元素对象 // . 类名 // # id名 element = document.querySelector(selectors); document.querySelectorAll(&quot;&quot;); //返回指定选择器的所有对象的集合 12345- **特殊元素获取** - ```javascript document.body; \\\\获取body document.documentElement; \\\\获取html 1234567891011121314151617181920212223- ​ **事件基础** - 事件是可被 JS 检测到的行为 - 事件三部分： 事件源 事件类型 事件处理程序 - 事件源： 事件被触发的对象 按钮 - 事件类型： 如何触发 什么事件 - 事件处理程序 ： 通过一个函数赋值的方式完成 - 执行事件的步骤 - 获取事件源 - 注册事件（绑定事件） - 添加事件处理程序（采取函数赋值形式）- **操作元素** - 改变元素内容 - ```javascript //从起始位置到终止位置的内容，但它去除html标签，同时空格和换行也会去掉 element.innerText //起始位置到终止位置的全部内容，包括html标签，同时保留空格和换行 element.innerHTML innerText 不识别html的标签 （非标准） innerHTML 识别html标签 （w3c 标准） 以上可以获取标签内容 ```javascript事件源.innerText; // 会去除空格和换行 事件源.innerHTML; // 不去除换行和空格 12345- 改变表单元素的属性操作 - ```javascript 事件元素.属性 = &quot;修改后的&quot;； 利用DOM可以操作如下表单元素的属性： type、value、checked、selected、disableJad","link":"/2022/09/26/JavaScript%E6%A0%B8%E5%BF%83Web-APIs-1/"},{"title":"【Leedcode题目总结】-76.最小覆盖子串","text":"【Leedcode题目总结】-76.最小覆盖子串1234给你一个字符串 s 、一个字符串 t 。返回 s 中涵盖 t 所有字符的最小子串。如果 s 中不存在涵盖 t 所有字符的子串，则返回空字符串 &quot;&quot; 。注意：对于 t 中重复字符，我们寻找的子字符串中该字符数量必须不少于 t 中该字符数量。如果 s 中存在这样的子串，我们保证它是唯一的答案。 思路： 使用 map 和 滑动窗口 定义两个map need(用来存放t中字符以及对应的数目)， window（存放当前窗口包含t中的字符和数目） 定义 变量valid（表示window中满足need的数目），当vaid==need.size时，更新最小长度以及起始位置同时开始滑动窗口，滑动时更新vaild以及window。 代码 123456789101112131415161718192021222324252627282930313233343536373839/** * @param {string} s * @param {string} t * @return {string} */var minWindow = function(s, t) { // 定义两个map 分别用来统计 t的字符种类和数目， 当前窗口中包含t的字符种类和数目 const need = new Map(); const window = new Map(); for(let c of t) { need.set(c, need.has(c) ? need.get(c) + 1 : 1); } let left = 0, right = 0; let valid = 0; let start = 0, len = 100001; while(right &lt; s.length) { let c = s[right]; right++; if(need.has(c)) { window.set(c, window.has(c) ? window.get(c) + 1 : 1); if(window.get(c) === need.get(c)) valid++; } // 当满足条件的字符够了的时候进行滑动 while(valid === need.size) { if(right - left &lt; len) { start = left; len = right - left; } let d = s[left]; left++; if(need.has(d)) { if(window.get(d) === need.get(d)) valid--; window.set(d, window.get(d) - 1); } } } return len === 100001 ? '' : s.substr(start, len);}; 注意： 声明map的方式 set时不可以使用自加，自减 变量作为map索引时不需要加 ’ ‘，常量作为索引需要加","link":"/2022/09/30/%E3%80%90Leedcode%E9%A2%98%E7%9B%AE%E6%80%BB%E7%BB%93%E3%80%91-76-%E6%9C%80%E5%B0%8F%E8%A6%86%E7%9B%96%E5%AD%90%E4%B8%B2/"},{"title":"回流 & 重绘 （Reflow & Repaint）","text":"相关知识点1、浏览器使用流式布局模型（Flow Based Layout）网页布局中包括:静态布局，流式布局，响应式布局和弹性布局几种情况。 静态布局：指的就是网页中的所有元素都使用px为单位。不管浏览器具体的大小是多少，始终按照设置的值布局来显示，由于浏览器大小不一，这样的布局很容易在不同设备中出现滚动条等问题。所以这种布局在移动开发不是主流的布局方式。 流式布局：是页面中元素的宽度按照屏幕分辨率自动进行适配调整，也就是我们常说的适配，它可以保证当前屏幕分辨率发生改变的时候，页面中的元素大小也可以跟着改变，所以流式布局是移动端开发常用的一种布局。 2、浏览器会把HTMl解析成DOM，把CSS解析成CSSOM，DOM和CSSOM合并产生Render Tree（渲染树）3、通过Render Tree 可以知道所有节点的样式，然后计算他们在页面上的大小和位置，最后把节点绘制到页面上4、流式布局对Render Tree 只需要一次遍历就可以计算完成，但table及其内部元素除外，他们可能需要多次计算，通常需要花三倍于同等元素的时间，这也是为什么要避免使用table布局的原因之一。回流必将引起重绘，重绘不一定会引起回流 回流（Reflow）当Render Tree中部分或全部元素的尺寸、结构、或某些属性发生改变时，浏览器重新渲染部分或全部文档的过程称为回流。 会导致回流的操作： 页面首次渲染 浏览器窗口大小发生改变 元素尺寸或位置发生改变 元素内容变化（文字数量或图片大小等等） 元素字体大小变化 添加或者删除可见的DOM元素 激活CSS伪类（例如：:hover） 查询某些属性或调用某些方法 一些常用且会导致回流的属性和方法： clientWidth、clientHeight、clientTop、clientLeft offsetWidth、offsetHeight、offsetTop、offsetLeft scrollWidth、scrollHeight、scrollTop、scrollLeft scrollIntoView()、scrollIntoViewIfNeeded() getComputedStyle() getBoundingClientRect() scrollTo() 重绘（Repaint） 当页面中元素样式的改变并不影响它在文档流中的位置时（例如：color、background-color、visibility等），浏览器会将新样式赋予给元素并重新绘制它，这个过程称为重绘。 性能影响回流比重绘的代价要更高。 有时即使仅仅回流一个单一的元素，它的父元素以及任何跟随它的元素也会产生回流。 现代浏览器会对频繁的回流或重绘操作进行优化： 浏览器会维护一个队列，把所有引起回流和重绘的操作放入队列中，如果队列中的任务数量或者时间间隔达到一个阈值的，浏览器就会将队列清空，进行一次批处理，这样可以把多次回流和重绘变成一次。 当你访问以下属性或方法时，浏览器会立刻清空队列： clientWidth、clientHeight、clientTop、clientLeft offsetWidth、offsetHeight、offsetTop、offsetLeft scrollWidth、scrollHeight、scrollTop、scrollLeft width、height getComputedStyle() getBoundingClientRect() 因为队列中可能会有影响到这些属性或方法返回值的操作，即使你希望获取的信息与队列中操作引发的改变无关，浏览器也会强行清空队列，确保你拿到的值是最精确的。 如何避免CSS 避免使用table布局。 尽可能在DOM树的最末端改变class。 避免设置多层内联样式。 将动画效果应用到position属性为absolute或fixed的元素上。 避免使用CSS表达式（例如：calc()）。 JavaScript 避免频繁操作样式，最好一次性重写style属性，或者将样式列表定义为class并一次性更改class属性。 避免频繁操作DOM，创建一个documentFragment，在它上面应用所有DOM操作，最后再把它添加到文档中。 也可以先为元素设置display: none，操作结束后再把它显示出来。因为在display属性为none的元素上进行的DOM操作不会引发回流和重绘。 避免频繁读取会引发回流/重绘的属性，如果确实需要多次使用，就用一个变量缓存起来。 对具有复杂动画的元素使用绝对定位，使它脱离文档流，否则会引起父元素及后续元素频繁回流。","link":"/2022/09/30/%E5%9B%9E%E6%B5%81-%E9%87%8D%E7%BB%98-%EF%BC%88Reflow-Repaint%EF%BC%89/"},{"title":"DOM事件流","text":"DOM文档对象模型 （Document Object Model， 简称DOM）， 是W3C组织推荐的处理可扩展标记语言（HTML 或者 XML） 的标准编程接口。 DOM树 文档：一个页面一个文档，DOM使用document表示 元素：页面中的所有标签都是元素，DOM中使用element表示 节点： 网页中所有内容都是节点（标签、属性、文本、注释等），DOM中使用node表示 以上内容都看作对象 获取元素 根据ID获取 使用 getElementById() 方法获取 Document的方法 getElementById()返回一个匹配特定 ID的元素。由于元素的 ID 在大部分情况下要求是独一无二的，这个方法自然而然地成为了一个高效查找特定元素的方法。 如果需要查找到那些没有 ID 的元素，你可以考虑通过 CSS 选择器使用 querySelector()。 语法 1var element = document.getElementById(id); Copy to Clipboard 参数 **element**是一个 Element 对象。如果当前文档中拥有特定 ID 的元素不存在则返回 null. **id**是大小写敏感的字符串，代表了所要查找的元素的唯一 ID. 返回值 返回一个匹配到 ID 的 DOM Element 对象。若在当前 Document 下没有找到，则返回 null。 根据标签名获取 使用getElementsTagName()方法返回带有指定标签名的对象的集合（以伪数组的形式存储）。 获取某个元素（父元素）内部所有指定标签名的子元素 1element.getElementsByTagName('标签名') 注意：父元素必须是单个对象（必须指明是哪一个元素对象）。获取的时候不包括父元素自己 通过HTML5新增的方法获取 document.getElementsByClassName('类名');// 根据类名返回元素对象集合 1234567- ```javascript document.querySelector(&quot;.类名&quot;); // 返回指定选择器的第一个元素对象 // . 类名 // # id名 element = document.querySelector(selectors); document.querySelectorAll(&quot;&quot;); //返回指定选择器的所有对象的集合 12345- **特殊元素获取** - ```javascript document.body; \\\\获取body document.documentElement; \\\\获取html 1234567891011121314151617181920212223- ​ **事件基础** - 事件是可被 JS 检测到的行为 - 事件三部分： 事件源 事件类型 事件处理程序 - 事件源： 事件被触发的对象 按钮 - 事件类型： 如何触发 什么事件 - 事件处理程序 ： 通过一个函数赋值的方式完成 - 执行事件的步骤 - 获取事件源 - 注册事件（绑定事件） - 添加事件处理程序（采取函数赋值形式）- **操作元素** - 改变元素内容 - ```javascript //从起始位置到终止位置的内容，但它去除html标签，同时空格和换行也会去掉 element.innerText //起始位置到终止位置的全部内容，包括html标签，同时保留空格和换行 element.innerHTML innerText 不识别html的标签 （非标准） innerHTML 识别html标签 （w3c 标准） 以上可以获取标签内容 ```javascript事件源.innerText; // 会去除空格和换行 事件源.innerHTML; // 不去除换行和空格 12345- 改变表单元素的属性操作 - ```javascript 事件元素.属性 = &quot;修改后的&quot;； 利用DOM可以操作如下表单元素的属性： type、value、checked、selected、disableJad 修改样式属性（修改CSS） 通过JS修改元素的大小、颜色、位置等样式 ```javascriptelement.style \\行内样式操作element.className \\类名样式操作 12345678910- 如果样式修改较多，可以采取操作类名方式更改元素样式- class因为是个保留字，因此使用className来操作元素类名属性- className会直接更改元素的类名，会覆盖原先的类名 - ``` 如果想要保留原先类名 this.className = '原先类名 新类名'； 排他思想 如果有同一组元素，我们想要某一个元素实现某种样式，需要用到循环的排他思想算法： 所有元素全部清除样式 给当前元素设置样式 注意顺序不能颠倒，首先干掉其他人，再设置自己 自定义属性的操作 获取元素 element.属性 element.getAttribute('属性') 12345678910 - 两者区别 - element.属性 获取内置属性值（元素本身自带的属性） - element.getAttribute('属性') 主要获得自定义属性（标准）- 设置属性值 - ```javascript element.属性 = 'value'; ```javascriptelement.setAttribute(‘属性’， ‘value’); 12345678910111213- 主要目的 - 为了保存并使用数据。有些数据可以保存到页面中不需要保存到数据库中。- 设置H5自定义属性 - H5规定自定义属性data-开头作为属性名并且赋值- H5新增的获取自定义属性的方法 ```javascript document.dataset.属性名称； 如果自定义属性有多个 ’-‘ 链接的单词，获取时采取驼峰命名法 123data-list-nameconsole.log(div.dataset['listName']); 节点操作 利用节点层级关系获取元素 利用父子兄节点关系获取元素 逻辑性强，但是兼容性稍差 一般来说，节点至少有nodeName（节点名称）、nodeType（节点类型）、nodeValue（节点值）三个基本属性 元素节点 节点类型取值（nodeType） 元素element 1 属性attr 2 文本text 3 注释comments 8 文档document 9 注册事件概述 给元素添加事件，称为注册事件或者绑定事件 注册事件有两种方式： 传统方式 和 方法监听注册事件 传统注册方式 ： 利用on开头的事件（onclick） 特点：注册事件的唯一性，同一个元素同一个事件只能处理一个函数，最后注册的处理函数将会覆盖前面注册的处理函数 方法监听注册方式 w3c标准推荐方式 addEventListener（） IE9 之前的IE不支持此方法，可使用attachEvent（）代替 同一个元素同一个事件可以注册多个监听器，按照注册顺序执行 123btns[1].addEventListener('click', function() { alert(22); }) DOM 事件流 事件流描述的是从页面中接收事件的顺序。 事件发生时会在元素节点之间按照特定的顺序传播，这个传播过程 即 DOM事件流 分为三个阶段 捕获阶段 当前目标阶段 冒泡阶段 dom 事件流 三个阶段 ​ 1. JS 代码中只能执行捕获或者冒泡其中的一个阶段。 ​ 2. onclick 和 attachEvent（ie） 只能得到冒泡阶段。 3. 捕获阶段 如果addEventListener 第三个参数是 true 那么则处于捕获阶段 document -&gt; html -&gt; body -&gt; father -&gt; son 123456789101112131415var son = document.querySelector('.son');​ son.addEventListener('click', function() { alert('son');​ }, true);var father = document.querySelector('.father');​ father.addEventListener('click', function() {​ alert('father');​ }, true); ​ 4. 冒泡阶段 如果addEventListener 第三个参数是 false 或者 省略 那么则处于冒泡阶段 son -&gt; father -&gt;body -&gt; html -&gt; document","link":"/2022/10/07/JavaScript%E6%A0%B8%E5%BF%83DOM-2/"},{"title":"Ajax-传统请求以及缺点","text":"传统请求及缺点12345678910111213141516171819&lt;!-- 直接在浏览器地址上输入URL --&gt; &lt;!-- 超链接 --&gt; &lt;a href=&quot;old/request&quot;&gt;传统请求（超链接）&lt;/a&gt; &lt;!-- form表单提交 --&gt; &lt;form action=&quot;&quot; method=&quot;get&quot;&gt; &lt;input type=&quot;submit&quot; value=&quot;传统请求(form表单提交)&quot;&gt; &lt;/form&gt; &lt;!-- 通过JS代码来发送请求 --&gt; &lt;input type=&quot;button&quot; value=&quot;传统请求(通过JS代码发送请求)&quot; onclick=&quot;sendRequest()&quot;&gt; &lt;script type=&quot;text/javascript&quot;&gt; function sendRequest() { //发送请求 // window.location.href = ''; document.location.href = 'old/request' } &lt;/script&gt; 存在的问题 页面会全部刷新导致了用户的体验较差 传统的请求导致用户的体验有空白期（用户体验不连贯） 例如：当播放视频时，点击登录按钮 传统请求会将全部页面刷新，视频缓存重新开始，视频间断 Ajax 仅仅更新登录模块内容，不刷新整个页面","link":"/2022/10/21/Ajax-%E4%BC%A0%E7%BB%9F%E8%AF%B7%E6%B1%82%E4%BB%A5%E5%8F%8A%E7%BC%BA%E7%82%B9/"},{"title":"什么是”耦合“和”解耦“？","text":"程序员所说的“耦合”和“解耦”在工程中，对象之间的耦合度就是对象之间的依赖性。对象之间的耦合越高，维护成本越高，因此对象的设计应使类和构件之间的耦合最小。 耦合的分类 分类：有软硬件之间的耦合，还有软件各模块之间的耦合。耦合性是程序结构中各个模块之间相互关联的度量。它取决于各个模块之间的接口的复杂程度、调用模块的方式以及哪些信息通过接口。 解耦 1、解耦，字面意思就是解除耦合关系。 2、在软件工程中，降低耦合度即可以理解为解耦，模块间有依赖关系必然存在耦合，理论上的绝对零耦合是做不到的，但可以通过一些现有的方法将耦合度降至最低。 3、设计的核心思想：尽可能减少代码耦合，如果发现代码耦合，就要采取解耦技术。让数据模型，业务逻辑和视图显示三层之间彼此降低耦合，把关联依赖降到最低，而不至于牵一发而动全身。原则就是A功能的代码不要写在B的功能代码中，如果两者之间需要交互，可以通过接口，通过消息，甚至可以引入框架，但总之就是不要直接交叉写。 4、观察者模式：观察者模式存在的意义就是「解耦」，它使观察者和被观察者的逻辑不再搅在一起，而是彼此独立、互不依赖。比如网易新闻的夜间模式，当用户切换成夜间模式之后，被观察者会通知所有的观察者「设置改变了，大家快蒙上遮罩吧」。QQ消息推送来了之后，既要在通知栏上弹个推送，又要在桌面上标个小红点，也是观察者与被观察者的巧妙配合。","link":"/2022/10/22/%E4%BB%80%E4%B9%88%E6%98%AF%E2%80%9D%E8%80%A6%E5%90%88%E2%80%9C%E5%92%8C%E2%80%9D%E8%A7%A3%E8%80%A6%E2%80%9C%EF%BC%9F/"},{"title":"Ajax-XMLHttpRequest对象","text":"XMLHttpRequest对象XMLHttpRequest（XHR）对象用于与服务器交互。通过 XMLHttpRequest 可以在不刷新页面的情况下请求特定 URL，获取数据。这允许网页在不影响用户操作的情况下，更新页面的局部内容。XMLHttpRequest 在 AJAX 编程中被大量使用。 通俗来讲，AJAX利用XHR对象作为中介进行服务器与客户端的连接和数据交换。 方法 方法 描述 abort() 取消当前请求 getAllResponseHeaders() 返回头部信息 getResponseHeader() 返回特定的头部信息 open(method, url, async, user, psw) 规定请求method，请求类型GET或POSTurl，文件位置async：true(异步) 或 false(同步)， user：可选的用户名称， psw：可选的密码 send() 将请求发送到服务器， 用于GET请求 send(string) 将请求发送到服务器， 用于POST请求 setRequestHeader() 向要发送的报头添加标签/值对 1234567891011121314151617181920212223242526272829303132333435363738394041424344// abort()xhrInstance.abort();//getAllResponseHeaders()var headers = XMLHttpRequest.getAllResponseHeaders();//原始的headerdate: Fri, 08 Dec 2017 21:04:30 GMT\\r\\ncontent-encoding: gzip\\r\\nx-content-type-options: nosniff\\r\\nserver: meinheld/0.6.1\\r\\nx-frame-options: DENY\\r\\ncontent-type: text/html; charset=utf-8\\r\\nconnection: keep-alive\\r\\nstrict-transport-security: max-age=63072000\\r\\nvary: Cookie, Accept-Encoding\\r\\ncontent-length: 6502\\r\\nx-xss-protection: 1; mode=block\\r\\n//getResponseHeader()var myHeader = XMLHttpRequest.getResponseHeader(name);//open(method, url, async, user, psw)//method//要使用的 HTTP 方法，比如 GET、POST、PUT、DELETE、等。对于非 HTTP(S) URL 被忽略。//url//一个 DOMString 表示要向其发送请求的 URL。//async 可选//一个可选的布尔参数，表示是否异步执行操作，默认为 true。如果值为 false，send() 方法直到收到答复前不会返回。如果 true，已完成事务的通知可供事件监听器使用。如果 multipart 属性为 true 则这个必须为 true，否则将引发异常。xhrReq.open(method, url);xhrReq.open(method, url, async);xhrReq.open(method, url, async, user);xhrReq.open(method, url, async, user, password);//send()//send(string)//setRequestHeader() 属性 属性 描述 onreadystatechange 定义当readyState属性发生变化时被调用的函数 readyState（只读） 保存XMLHttpRequest的状态，0：请求未初始化 1： 服务器连接以及建立 2：请求已收到 3：正在处理请求 4： 请求已完成且响应已就绪 responseText（只读） 以字符串返回响应的数据 responseXML（只读） 以XML返回响应数据 status（只读） 返回请求的状态号 200 ： ”OK“ 403 ：”Forbidden“ 404 ：”Not Found statusText（只读） 返回状态文本（”OK“ ”Not Found“） //onreadystatechange XMLHttpRequest.onreadystatechange = callback; // 语法 xhr.onreadystatechange = function() { }","link":"/2022/10/22/Ajax-XMLHttpRequest%E5%AF%B9%E8%B1%A1/"},{"title":"Ajax-GET请求缓存问题","text":"GET请求缓存问题 对于低版本的IE浏览器来说，AJAX的GET请求可能会走缓存。存在缓存问题 缓存问题是什么？ 在HTTP协议中规定GET请求会被浏览器缓存起来 如果多次访问同一地址的资源，会直接从浏览器的缓存中获取（不从服务器获取），无法得到服务器新更新后的资源 GET方式请求的数据会被浏览器缓存起来，因此其他人就可以从浏览器的历史记录中读取到这些数据，例如账号和密码等。在某种情况下，GET方式会带来严重的安全问题。而POST方式相对来说就可以避免这些问题。 如何解决缓存问题？ 可以在GET请求路径url后面添加一个时间戳（随时变化），使得每次发送的请求路径都不一样。 总之就是将每次请求的url变成唯一 POST请求在HTTP协议中规定：POST请求不会被浏览器缓存 选择GET 还是 POST ？ 与 POST 相比，GET 更简单也更快，并且在大部分情况下都能用。 “GET方式提交的数据最多只能是1024字节”，因为GET是通过URL提交数据，那么GET可提交的数据量就跟URL的长度有直接关系了。而实际上，URL不存在参数上限的问题，HTTP协议规范没有对URL长度进行限制。这个限制是特定的浏览器及服务器对它的限制。IE对URL长度的限制是2083字节(2K+35)。对于其他浏览器，如Netscape、FireFox等，理论上没有长度限制，其限制取决于操作系统的支持。注意这是限制是整个URL长度，而不仅仅是你的参数值数据长度。 在以下情况中，请使用 POST 请求： 不愿使用缓存文件（更新服务器上的文件或数据库） 向服务器发送大量数据（POST 没有数据量限制） 发送包含未知字符的用户输入时，POST 比 GET 更稳定也更可靠","link":"/2022/10/22/Ajax-GET%E8%AF%B7%E6%B1%82%E7%BC%93%E5%AD%98%E9%97%AE%E9%A2%98/"},{"title":"Ajax-Axios","text":"Axios 导入axios包 1234567891011121314使用 npm:$ npm install axios使用 bower:$ bower install axios使用 yarn:$ yarn add axios使用 jsDelivr CDN:&lt;script src=&quot;https://cdn.jsdelivr.net/npm/axios/dist/axios.min.js&quot;&gt;&lt;/script&gt;使用 unpkg CDN:&lt;script src=&quot;https://unpkg.com/axios/dist/axios.min.js&quot;&gt;&lt;/script&gt; 使用axios发送GET请求 发送GET请求 12345678910&lt;script&gt; document.querySelector('#btn').addEventListener('click', function(){ var urlGet = 'http://www.liulongbin.top:3006/api/get'; var paramsObj = {name : 'zs', age : 20}; // GET 方法 axios.get(url, {params: paramsObj}).then(function(res){ console.log(res.data); // 获取传入数据 console.log(res); });&lt;/script&gt; 使用axios发送POST请求 发送POST请求 12345678910&lt;script&gt; document.querySelector('#btn').addEventListener('click', function(){ var urlPost = 'http://www.liulongbin.top:3006/api/post'; var paramsObj = {name : 'zs', age : 20}; // GET 方法 axios.get(url, paramsObj).then(function(res){ console.log(res.data); // 获取传入数据 console.log(res); });&lt;/script&gt; 使用axios直接发送请求 直接发送请求（GET） 1234567891011121314&lt;script&gt; document.querySelector('#btn').addEventListener('click', function(){ var urlGet = 'http://www.liulongbin.top:3006/api/get'; var paramsObj = {name : 'zs', age : 20}; // GET 方法 axios({ method: 'GET', url: urlGet, parames : paramsObj }).then(function(res) { console.log(res.data); // 获取传入数据 console.log(res); }) &lt;/script&gt; 直接发送请求（POST） 1234567891011121314&lt;script&gt; document.querySelector('#btn').addEventListener('click', function(){ var urlPost = 'http://www.liulongbin.top:3006/api/post'; var dataObj = {name : 'zs', age : 20}; // POST 方法 axios({ method: 'POST', url: urlGet, data : dataObj }).then(function(res) { console.log(res.data); // 获取传入数据 console.log(res); }) &lt;/script&gt;","link":"/2022/10/28/Ajax-Axios/"},{"title":"【Leedcode题目总结】-239-滑动窗口最大值","text":"给你一个整数数组 nums，有一个大小为 k 的滑动窗口从数组的最左侧移动到数组的最右侧。你只可以看到在滑动窗口内的 k 个数字。滑动窗口每次只向右移动一位。 返回 滑动窗口中的最大值 。 示例 1： 1234567891011输入：nums = [1,3,-1,-3,5,3,6,7], k = 3输出：[3,3,5,5,6,7]解释：滑动窗口的位置 最大值--------------- -----[1 3 -1] -3 5 3 6 7 3 1 [3 -1 -3] 5 3 6 7 3 1 3 [-1 -3 5] 3 6 7 5 1 3 -1 [-3 5 3] 6 7 5 1 3 -1 -3 [5 3 6] 7 6 1 3 -1 -3 5 [3 6 7] 7 12345678910111213141516171819202122var maxSlidingWindow = function(nums, k) { let res = []; let que = []; // 队列最多容纳k个数 for(let i = 0; i &lt; nums.length; i++) { if(que.length === 0) que.push(nums[i]); else { // 维护队列 // 出队列就两种情况 // 1、 队头元素不在窗口（从队头出） // 2、 当前元素大于队尾元素（从队尾出） if(i - k &gt;= 0 &amp;&amp; nums[i - k] === que[0]) que.shift(); // 当队头元素出窗口时，弹出 // 当前元素若大于队尾元素，则移出，直到遇到小于的元素或者队列空了，进队 while(que.length &gt; 0 &amp;&amp; nums[i] &gt; que[que.length - 1]){ que.pop(); } que.push(nums[i]); } // 当滑动完k个元素之后开始提取队头元素 if(i &gt;= k - 1) res.push(que[0]); } return res;};","link":"/2022/10/28/%E3%80%90Leedcode%E9%A2%98%E7%9B%AE%E6%80%BB%E7%BB%93%E3%80%91-239-%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E6%9C%80%E5%A4%A7%E5%80%BC/"},{"title":"【Leedcode题目总结】-56-合并区间","text":"以数组 intervals 表示若干个区间的集合，其中单个区间为 intervals[i] = [starti, endi] 。请你合并所有重叠的区间，并返回 一个不重叠的区间数组，该数组需恰好覆盖输入中的所有区间 。 示例 1： 123输入：intervals = [[1,3],[2,6],[8,10],[15,18]]输出：[[1,6],[8,10],[15,18]]解释：区间 [1,3] 和 [2,6] 重叠, 将它们合并为 [1,6]. 1234567891011121314151617181920212223242526272829/** * @param {number[][]} intervals * @return {number[][]} */var merge = function(intervals) { if(intervals.length === 1) return intervals; //按照第一个数字大小进行排序 intervals.sort(function(arr1, arr2) { return arr1[0] - arr2[0]; }); var resArr = []; // 保留答案 var curArr = intervals[0]; // 指向当前需要比较的区间 intervals.push(0); for(let i = 0; i &lt; intervals.length ; i++) { // 如果当前区间末尾 大于 下一区间的开头 进行合并 // 循环至不满足条件 while(intervals[i] !== 0 &amp;&amp; curArr[1] &gt;= intervals[i][0]) { var temp = [curArr[0], curArr[1] &gt; intervals[i][1] ? curArr[1] : intervals[i][1]]; curArr = temp; i++; } // 将最终循环结果存入res，如果没有经过循环，说明不需要合并，直接存入 resArr.push(curArr); // 由于循环最后会指向第一个不满足循环条件的区间，所以更新当前区间 curArr = intervals[i]; } return resArr;};","link":"/2022/10/28/%E3%80%90Leedcode%E9%A2%98%E7%9B%AE%E6%80%BB%E7%BB%93%E3%80%91-56-%E5%90%88%E5%B9%B6%E5%8C%BA%E9%97%B4/"}],"tags":[{"name":"JS","slug":"JS","link":"/tags/JS/"},{"name":"Leedcode","slug":"Leedcode","link":"/tags/Leedcode/"},{"name":"计算机知识杂烩","slug":"计算机知识杂烩","link":"/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%9F%A5%E8%AF%86%E6%9D%82%E7%83%A9/"},{"name":"Ajax","slug":"Ajax","link":"/tags/Ajax/"},{"name":"CSS","slug":"CSS","link":"/tags/CSS/"},{"name":"JS-DOM","slug":"JS-DOM","link":"/tags/JS-DOM/"}],"categories":[]}